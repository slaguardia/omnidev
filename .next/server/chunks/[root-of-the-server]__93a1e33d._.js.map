{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/config/settings.ts"],"sourcesContent":["/**\n * Configuration management for GitLab Claude Manager\n */\n\nimport { config } from 'dotenv';\nimport { resolve } from 'node:path';\nimport type { AppConfig, GitLabConfig, ClaudeConfig, WorkspaceConfig, SecurityConfig, LoggingConfig } from '@/types/index';\n\n// Load environment variables\nconfig();\n\n/**\n * Get environment variable with type safety and default value\n */\nfunction getEnvVar<T = string>(\n  key: string,\n  defaultValue?: T,\n  parser?: (value: string) => T\n): T {\n  const value = process.env[key];\n  \n  if (value === undefined) {\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n    throw new Error(`Required environment variable ${key} is not set`);\n  }\n  \n  return parser ? parser(value) : (value as unknown as T);\n}\n\n/**\n * Parse boolean from string\n */\nfunction parseBoolean(value: string): boolean {\n  return value.toLowerCase() === 'true' || value === '1';\n}\n\n/**\n * Parse number from string\n */\nfunction parseNumber(value: string): number {\n  const num = parseInt(value, 10);\n  if (isNaN(num)) {\n    throw new Error(`Invalid number value: ${value}`);\n  }\n  return num;\n}\n\n/**\n * Parse comma-separated string to array\n */\nfunction parseStringArray(value: string): string[] {\n  return value.split(',').map(s => s.trim()).filter(s => s.length > 0);\n}\n\n/**\n * GitLab configuration\n */\nexport const gitlabConfig: GitLabConfig = {\n  url: getEnvVar('GITLAB_URL', 'https://gitlab.com'),\n  token: getEnvVar('GITLAB_TOKEN'),\n  allowedHosts: getEnvVar('ALLOWED_GITLAB_HOSTS', ['gitlab.com'], parseStringArray)\n};\n\n/**\n * Claude configuration\n */\nexport const claudeConfig: ClaudeConfig = {\n  apiKey: getEnvVar('CLAUDE_API_KEY'),\n  codeCliPath: getEnvVar('CLAUDE_CODE_PATH', 'claude-code'),\n  maxTokens: getEnvVar('CLAUDE_MAX_TOKENS', 4000, parseNumber),\n  defaultTemperature: getEnvVar('CLAUDE_TEMPERATURE', 0.3, parseFloat)\n};\n\n/**\n * Workspace configuration\n */\nexport const workspaceConfig: WorkspaceConfig = {\n  maxSizeMB: getEnvVar('MAX_WORKSPACE_SIZE_MB', 500, parseNumber),\n  maxConcurrent: getEnvVar('MAX_CONCURRENT_WORKSPACES', 3, parseNumber),\n  cacheExpiryDays: getEnvVar('CACHE_EXPIRY_DAYS', 7, parseNumber),\n  tempDirPrefix: getEnvVar('TEMP_DIR_PREFIX', 'gitlab-claude-')\n};\n\n/**\n * Security configuration\n */\nexport const securityConfig: SecurityConfig = {\n  allowedGitLabHosts: getEnvVar('ALLOWED_GITLAB_HOSTS', ['gitlab.com'], parseStringArray),\n  maxWorkspaceSize: getEnvVar('MAX_WORKSPACE_SIZE_MB', 500, parseNumber) * 1024 * 1024, // Convert to bytes\n  enableSandboxing: getEnvVar('ENABLE_SANDBOXING', true, parseBoolean)\n};\n\n/**\n * Logging configuration\n */\nexport const loggingConfig: LoggingConfig = {\n  level: getEnvVar('LOG_LEVEL', 'info') as LoggingConfig['level'],\n  format: getEnvVar('LOG_FORMAT', 'text') as LoggingConfig['format'],\n  enableFileLogging: getEnvVar('ENABLE_FILE_LOGGING', false, parseBoolean)\n};\n\n/**\n * Complete application configuration\n */\nexport const appConfig: AppConfig = {\n  gitlab: gitlabConfig,\n  claude: claudeConfig,\n  workspace: workspaceConfig,\n  security: securityConfig,\n  logging: loggingConfig\n};\n\n/**\n * Validate configuration\n */\nexport function validateConfig(): void {\n  const errors: string[] = [];\n\n  // Validate GitLab configuration\n  if (!gitlabConfig.token) {\n    errors.push('GITLAB_TOKEN is required');\n  }\n\n  if (!gitlabConfig.url.startsWith('http')) {\n    errors.push('GITLAB_URL must be a valid HTTP(S) URL');\n  }\n\n  // Validate Claude configuration\n  if (!claudeConfig.apiKey) {\n    errors.push('CLAUDE_API_KEY is required');\n  }\n\n  // Validate workspace limits\n  if (workspaceConfig.maxSizeMB <= 0) {\n    errors.push('MAX_WORKSPACE_SIZE_MB must be positive');\n  }\n\n  if (workspaceConfig.maxConcurrent <= 0) {\n    errors.push('MAX_CONCURRENT_WORKSPACES must be positive');\n  }\n\n  // Validate logging level\n  const validLogLevels = ['debug', 'info', 'warn', 'error'];\n  if (!validLogLevels.includes(loggingConfig.level)) {\n    errors.push('LOG_LEVEL must be one of: debug, info, warn, error');\n  }\n\n  if (errors.length > 0) {\n    throw new Error(`Configuration validation failed:\\n${errors.join('\\n')}`);\n  }\n}\n\n/**\n * Get workspace base directory\n */\nexport function getWorkspaceBaseDir(): string {\n  const baseDir = getEnvVar('WORKSPACE_BASE_DIR', resolve(process.cwd(), 'workspaces'));\n  return resolve(baseDir);\n}\n\n/**\n * Get cache directory\n */\nexport function getCacheDir(): string {\n  const cacheDir = getEnvVar('CACHE_DIR', resolve(process.cwd(), '.cache'));\n  return resolve(cacheDir);\n}\n\n/**\n * Check if running in development mode\n */\nexport function isDevelopment(): boolean {\n  return getEnvVar('NODE_ENV', 'development' as string) === 'development';\n}\n\n/**\n * Check if running in production mode\n */\nexport function isProduction(): boolean {\n  return getEnvVar('NODE_ENV', 'development' as string) === 'production';\n}\n\n/**\n * Initialize configuration\n */\nexport function initializeConfig(): void {\n  try {\n    validateConfig();\n    console.log('Configuration loaded successfully');\n    \n    if (isDevelopment()) {\n      console.log('Running in development mode');\n      console.log('Workspace base directory:', getWorkspaceBaseDir());\n      console.log('Cache directory:', getCacheDir());\n    }\n  } catch (error) {\n    console.error('Configuration initialization failed:', error);\n    process.exit(1);\n  }\n}\n\n// Auto-initialize on import in production\nif (isProduction()) {\n  initializeConfig();\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/managers/WorkspaceManager.ts"],"sourcesContent":["/**\r\n * Workspace Manager - Persistent workspace management\r\n */\r\n\r\nimport { writeFile, readFile, stat } from 'node:fs/promises';\r\nimport { join } from 'node:path';\r\nimport { getWorkspaceBaseDir } from '@/config/settings';\r\nimport type {\r\n  Workspace,\r\n  WorkspaceId,\r\n  FilePath,\r\n  AsyncResult\r\n} from '@/types/index';\r\n\r\ninterface WorkspaceIndex {\r\n  workspaces: Record<WorkspaceId, Workspace>;\r\n  lastUpdated: string;\r\n  version: string;\r\n}\r\n\r\n/**\r\n * Manages workspace persistence and state\r\n */\r\nexport class WorkspaceManager {\r\n  private readonly workspaceIndexPath: FilePath;\r\n  private workspaceIndex: WorkspaceIndex;\r\n\r\n  constructor() {\r\n    const workspaceBaseDir = getWorkspaceBaseDir();\r\n    this.workspaceIndexPath = join(workspaceBaseDir, '.workspace-index.json') as FilePath;\r\n    this.workspaceIndex = {\r\n      workspaces: {},\r\n      lastUpdated: new Date().toISOString(),\r\n      version: '1.0.0'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize workspace manager (load existing workspaces)\r\n   */\r\n  async initialize(): Promise<AsyncResult<void>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to initialize workspace manager: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save workspace to persistent storage\r\n   */\r\n  async saveWorkspace(workspace: Workspace): Promise<AsyncResult<void>> {\r\n    try {\r\n      this.workspaceIndex.workspaces[workspace.id] = workspace;\r\n      this.workspaceIndex.lastUpdated = new Date().toISOString();\r\n      \r\n      await this.saveWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to save workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load workspace from persistent storage\r\n   */\r\n  async loadWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<Workspace>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      \r\n      const workspace = this.workspaceIndex.workspaces[workspaceId];\r\n      if (!workspace) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspaceId} not found`)\r\n        };\r\n      }\r\n\r\n      // Update last accessed time\r\n      workspace.lastAccessed = new Date();\r\n      await this.saveWorkspace(workspace);\r\n\r\n      return { success: true, data: workspace };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to load workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all workspaces from persistent storage\r\n   */\r\n  async getAllWorkspaces(): Promise<AsyncResult<Workspace[]>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      \r\n      const workspaces = Object.values(this.workspaceIndex.workspaces)\r\n        .sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime());\r\n\r\n      return { success: true, data: workspaces };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to get all workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete workspace from persistent storage\r\n   */\r\n  async deleteWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<void>> {\r\n    try {\r\n      delete this.workspaceIndex.workspaces[workspaceId];\r\n      this.workspaceIndex.lastUpdated = new Date().toISOString();\r\n      \r\n      await this.saveWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to delete workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update workspace in persistent storage\r\n   */\r\n  async updateWorkspace(workspace: Workspace): Promise<AsyncResult<void>> {\r\n    try {\r\n      if (!this.workspaceIndex.workspaces[workspace.id]) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspace.id} not found`)\r\n        };\r\n      }\r\n\r\n      return await this.saveWorkspace(workspace);\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to update workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if workspace exists in storage\r\n   */\r\n  async workspaceExists(workspaceId: WorkspaceId): Promise<boolean> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      return workspaceId in this.workspaceIndex.workspaces;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace statistics\r\n   */\r\n  async getWorkspaceStats(): Promise<AsyncResult<{\r\n    total: number;\r\n    active: number;\r\n    inactive: number;\r\n    totalSize: number;\r\n    oldestAccess: Date | null;\r\n    newestAccess: Date | null;\r\n  }>> {\r\n    try {\r\n      const result = await this.getAllWorkspaces();\r\n      if (!result.success) {\r\n        return result;\r\n      }\r\n\r\n      const workspaces = result.data;\r\n      const active = workspaces.filter(ws => ws.metadata?.isActive);\r\n      const totalSize = workspaces.reduce((sum, ws) => sum + (ws.metadata?.size || 0), 0);\r\n      \r\n      const accessTimes = workspaces.map(ws => new Date(ws.lastAccessed));\r\n      const oldestAccess = accessTimes.length > 0 ? new Date(Math.min(...accessTimes.map(d => d.getTime()))) : null;\r\n      const newestAccess = accessTimes.length > 0 ? new Date(Math.max(...accessTimes.map(d => d.getTime()))) : null;\r\n\r\n      return {\r\n        success: true,\r\n        data: {\r\n          total: workspaces.length,\r\n          active: active.length,\r\n          inactive: workspaces.length - active.length,\r\n          totalSize,\r\n          oldestAccess,\r\n          newestAccess\r\n        }\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to get workspace stats: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup old workspaces (mark as inactive or delete)\r\n   */\r\n  async cleanupOldWorkspaces(maxAgeHours: number = 24 * 7): Promise<AsyncResult<number>> {\r\n    try {\r\n      const result = await this.getAllWorkspaces();\r\n      if (!result.success) {\r\n        return result;\r\n      }\r\n\r\n      const cutoffTime = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000);\r\n      let cleanedCount = 0;\r\n\r\n      for (const workspace of result.data) {\r\n        if (new Date(workspace.lastAccessed) < cutoffTime && workspace.metadata?.isActive) {\r\n          workspace.metadata.isActive = false;\r\n          await this.saveWorkspace(workspace);\r\n          cleanedCount++;\r\n        }\r\n      }\r\n\r\n      return { success: true, data: cleanedCount };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to cleanup old workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load workspace index from disk\r\n   */\r\n  private async loadWorkspaceIndex(): Promise<void> {\r\n    try {\r\n      await stat(this.workspaceIndexPath);\r\n      const content = await readFile(this.workspaceIndexPath, 'utf-8');\r\n      this.workspaceIndex = JSON.parse(content);\r\n      \r\n      // Convert date strings back to Date objects\r\n      Object.values(this.workspaceIndex.workspaces).forEach(workspace => {\r\n        workspace.createdAt = new Date(workspace.createdAt);\r\n        workspace.lastAccessed = new Date(workspace.lastAccessed);\r\n      });\r\n    } catch {\r\n      // File doesn't exist or is corrupted, start with empty index\r\n      this.workspaceIndex = {\r\n        workspaces: {},\r\n        lastUpdated: new Date().toISOString(),\r\n        version: '1.0.0'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save workspace index to disk\r\n   */\r\n  private async saveWorkspaceIndex(): Promise<void> {\r\n    const content = JSON.stringify(this.workspaceIndex, null, 2);\r\n    await writeFile(this.workspaceIndexPath, content, 'utf-8');\r\n  }\r\n\r\n  /**\r\n   * Get workspace index file path\r\n   */\r\n  getIndexPath(): FilePath {\r\n    return this.workspaceIndexPath;\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/app/api/workspaces/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { WorkspaceManager } from '@/managers/WorkspaceManager';\r\n\r\nconst workspaceManager = new WorkspaceManager();\r\n\r\nexport async function GET() {\r\n  try {\r\n    // Initialize workspace manager\r\n    const initResult = await workspaceManager.initialize();\r\n    if (!initResult.success) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to initialize workspace manager', details: initResult.error?.message },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // Get all workspaces\r\n    const workspacesResult = await workspaceManager.getAllWorkspaces();\r\n    if (!workspacesResult.success) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to get workspaces', details: workspacesResult.error?.message },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      workspaces: workspacesResult.data\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in workspaces API:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error', details: error instanceof Error ? error.message : String(error) },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,MAAM,mBAAmB,IAAI,qIAAA,CAAA,mBAAgB;AAEtC,eAAe;IACpB,IAAI;QACF,+BAA+B;QAC/B,MAAM,aAAa,MAAM,iBAAiB,UAAU;QACpD,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAA0C,SAAS,WAAW,KAAK,EAAE;YAAQ,GACtF;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,mBAAmB,MAAM,iBAAiB,gBAAgB;QAChE,IAAI,CAAC,iBAAiB,OAAO,EAAE;YAC7B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAA4B,SAAS,iBAAiB,KAAK,EAAE;YAAQ,GAC9E;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,YAAY,iBAAiB,IAAI;QACnC;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAAyB,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QAAO,GAClG;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}