{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/utils/gitOperations.ts"],"sourcesContent":["/**\n * Git operations utilities\n */\n\nimport { simpleGit, SimpleGit, CleanOptions } from 'simple-git';\nimport { resolve, join } from 'path';\nimport { mkdir, rmdir, stat } from 'fs/promises';\nimport type { GitUrl, FilePath, CommitHash, AsyncResult } from '@/types/index';\n\nexport interface GitCloneOptions {\n  branch?: string;\n  depth?: number;\n  singleBranch?: boolean;\n  bare?: boolean;\n}\n\nexport interface GitCommitInfo {\n  hash: CommitHash;\n  message: string;\n  author: string;\n  date: Date;\n}\n\nexport interface GitBranchInfo {\n  name: string;\n  isRemote: boolean;\n  isCurrent: boolean;\n  commitHash: CommitHash;\n}\n\n/**\n * Git operations manager\n */\nexport class GitOperations {\n  private git: SimpleGit;\n\n  constructor(workingDirectory?: string) {\n    this.git = simpleGit(workingDirectory || process.cwd());\n  }\n\n  /**\n   * Clone a repository to a local directory\n   */\n  async cloneRepository(\n    repoUrl: GitUrl, \n    targetPath: FilePath,\n    options: GitCloneOptions = {}\n  ): Promise<AsyncResult<void>> {\n    try {\n      // Ensure target directory exists\n      await this.ensureDirectoryExists(targetPath);\n\n      const cloneOptions: string[] = [];\n\n      if (options.depth) {\n        cloneOptions.push('--depth', options.depth.toString());\n      }\n\n      if (options.singleBranch) {\n        cloneOptions.push('--single-branch');\n      }\n\n      if (options.branch) {\n        cloneOptions.push('--branch', options.branch);\n      }\n\n      if (options.bare) {\n        cloneOptions.push('--bare');\n      }\n\n      await this.git.clone(repoUrl, targetPath, cloneOptions);\n\n      // Add to Git safe directories to prevent ownership issues\n      await this.addToSafeDirectory(targetPath);\n\n      return { success: true, data: undefined };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to clone repository: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Get current commit hash\n   */\n  async getCurrentCommitHash(workspacePath: FilePath): Promise<AsyncResult<CommitHash>> {\n    try {\n      const git = simpleGit(workspacePath);\n      const log = await git.log(['-1', '--format=%H']);\n      const hash = log.latest?.hash;\n\n      if (!hash) {\n        return {\n          success: false,\n          error: new Error('No commits found in repository')\n        };\n      }\n\n      return { success: true, data: hash as CommitHash };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to get commit hash: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Get current branch name\n   */\n  async getCurrentBranch(workspacePath: FilePath): Promise<AsyncResult<string>> {\n    try {\n      const git = simpleGit(workspacePath);\n      \n      // Try to add to safe directory first if we get an ownership error\n      try {\n        const status = await git.status();\n        const currentBranch = status.current;\n\n        if (!currentBranch) {\n          return {\n            success: false,\n            error: new Error('No current branch found (detached HEAD?)')\n          };\n        }\n\n        return { success: true, data: currentBranch };\n      } catch (error) {\n        // If it's an ownership error, try adding to safe directory and retry\n        if (String(error).includes('dubious ownership')) {\n          await this.addToSafeDirectory(workspacePath);\n          \n          // Retry after adding to safe directory\n          const status = await git.status();\n          const currentBranch = status.current;\n\n          if (!currentBranch) {\n            return {\n              success: false,\n              error: new Error('No current branch found (detached HEAD?)')\n            };\n          }\n\n          return { success: true, data: currentBranch };\n        }\n        \n        // Re-throw if it's not an ownership error\n        throw error;\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to get current branch: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Get commit information\n   */\n  async getCommitInfo(workspacePath: FilePath, commitHash?: CommitHash): Promise<AsyncResult<GitCommitInfo>> {\n    try {\n      const git = simpleGit(workspacePath);\n      const log = await git.log(['-1', commitHash || 'HEAD']);\n      const commit = log.latest;\n\n      if (!commit) {\n        return {\n          success: false,\n          error: new Error('Commit not found')\n        };\n      }\n\n      const info: GitCommitInfo = {\n        hash: commit.hash as CommitHash,\n        message: commit.message,\n        author: `${commit.author_name} <${commit.author_email}>`,\n        date: new Date(commit.date)\n      };\n\n      return { success: true, data: info };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to get commit info: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Get all branches\n   */\n  async getBranches(workspacePath: FilePath): Promise<AsyncResult<GitBranchInfo[]>> {\n    try {\n      const git = simpleGit(workspacePath);\n      const branches = await git.branch(['--all']);\n\n      const branchInfo: GitBranchInfo[] = [];\n\n      for (const [branchName, branchData] of Object.entries(branches.branches)) {\n        if (branchName === 'HEAD') continue;\n\n        branchInfo.push({\n          name: branchName,\n          isRemote: branchName.startsWith('remotes/'),\n          isCurrent: branchData.current,\n          commitHash: branchData.commit as CommitHash\n        });\n      }\n\n      return { success: true, data: branchInfo };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to get branches: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Switch to a different branch\n   */\n  async switchBranch(workspacePath: FilePath, branchName: string): Promise<AsyncResult<void>> {\n    try {\n      const git = simpleGit(workspacePath);\n      \n      // Check if branch exists locally\n      const branches = await git.branch();\n      const localBranches = Object.keys(branches.branches);\n      \n      if (localBranches.includes(branchName)) {\n        // Switch to existing local branch\n        await git.checkout(branchName);\n      } else {\n        // Create and switch to new branch from remote\n        await git.checkoutLocalBranch(branchName);\n      }\n\n      return { success: true, data: undefined };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to switch branch: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Pull latest changes from remote\n   */\n  async pullChanges(workspacePath: FilePath): Promise<AsyncResult<void>> {\n    try {\n      const git = simpleGit(workspacePath);\n      await git.pull();\n\n      return { success: true, data: undefined };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to pull changes: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Check if directory is a Git repository\n   */\n  async isGitRepository(directoryPath: FilePath): Promise<boolean> {\n    try {\n      const git = simpleGit(directoryPath);\n      await git.status();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get repository status\n   */\n  async getStatus(workspacePath: FilePath): Promise<AsyncResult<{\n    isClean: boolean;\n    staged: string[];\n    modified: string[];\n    untracked: string[];\n  }>> {\n    try {\n      const git = simpleGit(workspacePath);\n      const status = await git.status();\n\n      return {\n        success: true,\n        data: {\n          isClean: status.isClean(),\n          staged: status.staged,\n          modified: status.modified,\n          untracked: status.not_added\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to get status: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Get repository remote URL\n   */\n  async getRemoteUrl(workspacePath: FilePath, remoteName = 'origin'): Promise<AsyncResult<GitUrl>> {\n    try {\n      const git = simpleGit(workspacePath);\n      const remotes = await git.getRemotes(true);\n      const remote = remotes.find(r => r.name === remoteName);\n\n      if (!remote?.refs?.fetch) {\n        return {\n          success: false,\n          error: new Error(`Remote '${remoteName}' not found`)\n        };\n      }\n\n      return { success: true, data: remote.refs.fetch as GitUrl };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to get remote URL: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Clean workspace (remove untracked files and directories)\n   */\n  async cleanWorkspace(workspacePath: FilePath, force = false): Promise<AsyncResult<void>> {\n    try {\n      const git = simpleGit(workspacePath);\n      \n      if (force) {\n        await git.clean(CleanOptions.FORCE + CleanOptions.RECURSIVE);\n      } else {\n        await git.clean(CleanOptions.DRY_RUN + CleanOptions.RECURSIVE);\n      }\n\n      return { success: true, data: undefined };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to clean workspace: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Reset workspace to last commit\n   */\n  async resetWorkspace(workspacePath: FilePath, hard = false): Promise<AsyncResult<void>> {\n    try {\n      const git = simpleGit(workspacePath);\n      \n      if (hard) {\n        await git.reset(['--hard', 'HEAD']);\n      } else {\n        await git.reset(['HEAD']);\n      }\n\n      return { success: true, data: undefined };\n    } catch (error) {\n      return {\n        success: false,\n        error: new Error(`Failed to reset workspace: ${error}`)\n      };\n    }\n  }\n\n  /**\n   * Ensure directory exists\n   */\n  private async ensureDirectoryExists(directoryPath: FilePath): Promise<void> {\n    try {\n      await stat(directoryPath);\n    } catch {\n      // Directory doesn't exist, create it\n      await mkdir(directoryPath, { recursive: true });\n    }\n  }\n\n  /**\n   * Validate Git URL format\n   */\n  static validateGitUrl(url: string): boolean {\n    // Basic Git URL validation\n    const gitUrlPatterns = [\n      /^https?:\\/\\/.+\\.git$/i,                    // HTTPS\n      /^git@.+:.+\\.git$/i,                        // SSH\n      /^ssh:\\/\\/git@.+\\/.+\\.git$/i,              // SSH with protocol\n      /^https?:\\/\\/.+\\/.+$/i                      // HTTPS without .git\n    ];\n\n    return gitUrlPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extract repository name from URL\n   */\n  static extractRepoName(url: GitUrl): string {\n    const urlStr = url.toString();\n    const parts = urlStr.split('/');\n    const lastPart = parts[parts.length - 1] || '';\n    \n    // Remove .git extension if present\n    return lastPart.replace(/\\.git$/, '') || 'unknown-repo';\n  }\n\n  /**\n   * Generate safe directory name from repository URL\n   */\n  static generateSafeDirName(url: GitUrl, branch?: string): string {\n    const repoName = GitOperations.extractRepoName(url);\n    const safeName = repoName.replace(/[^a-zA-Z0-9-_]/g, '-');\n    \n    if (branch && branch !== 'main' && branch !== 'master') {\n      return `${safeName}-${branch.replace(/[^a-zA-Z0-9-_]/g, '-')}`;\n    }\n    \n    return safeName;\n  }\n\n  /**\n   * Add directory to Git safe directories to prevent ownership issues\n   */\n  private async addToSafeDirectory(directoryPath: FilePath): Promise<void> {\n    try {\n      await this.git.raw(['config', '--global', '--add', 'safe.directory', directoryPath]);\n    } catch (error) {\n      // Non-fatal error - log but don't fail the operation\n      console.warn(`Warning: Could not add ${directoryPath} to Git safe directories:`, error);\n    }\n  }\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/config/settings.ts"],"sourcesContent":["/**\n * Configuration management for GitLab Claude Manager\n */\n\nimport { config } from 'dotenv';\nimport { resolve } from 'node:path';\nimport type { AppConfig, GitLabConfig, ClaudeConfig, WorkspaceConfig, SecurityConfig, LoggingConfig } from '@/types/index';\n\n// Load environment variables\nconfig();\n\n/**\n * Get environment variable with type safety and default value\n */\nfunction getEnvVar<T = string>(\n  key: string,\n  defaultValue?: T,\n  parser?: (value: string) => T\n): T {\n  const value = process.env[key];\n  \n  if (value === undefined) {\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n    throw new Error(`Required environment variable ${key} is not set`);\n  }\n  \n  return parser ? parser(value) : (value as unknown as T);\n}\n\n/**\n * Parse boolean from string\n */\nfunction parseBoolean(value: string): boolean {\n  return value.toLowerCase() === 'true' || value === '1';\n}\n\n/**\n * Parse number from string\n */\nfunction parseNumber(value: string): number {\n  const num = parseInt(value, 10);\n  if (isNaN(num)) {\n    throw new Error(`Invalid number value: ${value}`);\n  }\n  return num;\n}\n\n/**\n * Parse comma-separated string to array\n */\nfunction parseStringArray(value: string): string[] {\n  return value.split(',').map(s => s.trim()).filter(s => s.length > 0);\n}\n\n/**\n * GitLab configuration\n */\nexport const gitlabConfig: GitLabConfig = {\n  url: getEnvVar('GITLAB_URL', 'https://gitlab.com'),\n  token: getEnvVar('GITLAB_TOKEN'),\n  allowedHosts: getEnvVar('ALLOWED_GITLAB_HOSTS', ['gitlab.com'], parseStringArray)\n};\n\n/**\n * Claude configuration\n */\nexport const claudeConfig: ClaudeConfig = {\n  apiKey: getEnvVar('CLAUDE_API_KEY'),\n  codeCliPath: getEnvVar('CLAUDE_CODE_PATH', 'claude-code'),\n  maxTokens: getEnvVar('CLAUDE_MAX_TOKENS', 4000, parseNumber),\n  defaultTemperature: getEnvVar('CLAUDE_TEMPERATURE', 0.3, parseFloat)\n};\n\n/**\n * Workspace configuration\n */\nexport const workspaceConfig: WorkspaceConfig = {\n  maxSizeMB: getEnvVar('MAX_WORKSPACE_SIZE_MB', 500, parseNumber),\n  maxConcurrent: getEnvVar('MAX_CONCURRENT_WORKSPACES', 3, parseNumber),\n  cacheExpiryDays: getEnvVar('CACHE_EXPIRY_DAYS', 7, parseNumber),\n  tempDirPrefix: getEnvVar('TEMP_DIR_PREFIX', 'gitlab-claude-')\n};\n\n/**\n * Security configuration\n */\nexport const securityConfig: SecurityConfig = {\n  allowedGitLabHosts: getEnvVar('ALLOWED_GITLAB_HOSTS', ['gitlab.com'], parseStringArray),\n  maxWorkspaceSize: getEnvVar('MAX_WORKSPACE_SIZE_MB', 500, parseNumber) * 1024 * 1024, // Convert to bytes\n  enableSandboxing: getEnvVar('ENABLE_SANDBOXING', true, parseBoolean)\n};\n\n/**\n * Logging configuration\n */\nexport const loggingConfig: LoggingConfig = {\n  level: getEnvVar('LOG_LEVEL', 'info') as LoggingConfig['level'],\n  format: getEnvVar('LOG_FORMAT', 'text') as LoggingConfig['format'],\n  enableFileLogging: getEnvVar('ENABLE_FILE_LOGGING', false, parseBoolean)\n};\n\n/**\n * Complete application configuration\n */\nexport const appConfig: AppConfig = {\n  gitlab: gitlabConfig,\n  claude: claudeConfig,\n  workspace: workspaceConfig,\n  security: securityConfig,\n  logging: loggingConfig\n};\n\n/**\n * Validate configuration\n */\nexport function validateConfig(): void {\n  const errors: string[] = [];\n\n  // Validate GitLab configuration\n  if (!gitlabConfig.token) {\n    errors.push('GITLAB_TOKEN is required');\n  }\n\n  if (!gitlabConfig.url.startsWith('http')) {\n    errors.push('GITLAB_URL must be a valid HTTP(S) URL');\n  }\n\n  // Validate Claude configuration\n  if (!claudeConfig.apiKey) {\n    errors.push('CLAUDE_API_KEY is required');\n  }\n\n  // Validate workspace limits\n  if (workspaceConfig.maxSizeMB <= 0) {\n    errors.push('MAX_WORKSPACE_SIZE_MB must be positive');\n  }\n\n  if (workspaceConfig.maxConcurrent <= 0) {\n    errors.push('MAX_CONCURRENT_WORKSPACES must be positive');\n  }\n\n  // Validate logging level\n  const validLogLevels = ['debug', 'info', 'warn', 'error'];\n  if (!validLogLevels.includes(loggingConfig.level)) {\n    errors.push('LOG_LEVEL must be one of: debug, info, warn, error');\n  }\n\n  if (errors.length > 0) {\n    throw new Error(`Configuration validation failed:\\n${errors.join('\\n')}`);\n  }\n}\n\n/**\n * Get workspace base directory\n */\nexport function getWorkspaceBaseDir(): string {\n  const baseDir = getEnvVar('WORKSPACE_BASE_DIR', resolve(process.cwd(), 'workspaces'));\n  return resolve(baseDir);\n}\n\n/**\n * Get cache directory\n */\nexport function getCacheDir(): string {\n  const cacheDir = getEnvVar('CACHE_DIR', resolve(process.cwd(), '.cache'));\n  return resolve(cacheDir);\n}\n\n/**\n * Check if running in development mode\n */\nexport function isDevelopment(): boolean {\n  return getEnvVar('NODE_ENV', 'development' as string) === 'development';\n}\n\n/**\n * Check if running in production mode\n */\nexport function isProduction(): boolean {\n  return getEnvVar('NODE_ENV', 'development' as string) === 'production';\n}\n\n/**\n * Initialize configuration\n */\nexport function initializeConfig(): void {\n  try {\n    validateConfig();\n    console.log('Configuration loaded successfully');\n    \n    if (isDevelopment()) {\n      console.log('Running in development mode');\n      console.log('Workspace base directory:', getWorkspaceBaseDir());\n      console.log('Cache directory:', getCacheDir());\n    }\n  } catch (error) {\n    console.error('Configuration initialization failed:', error);\n    process.exit(1);\n  }\n}\n\n// Auto-initialize on import in production\nif (isProduction()) {\n  initializeConfig();\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/managers/RepositoryManager.ts"],"sourcesContent":["/**\r\n * Repository Manager - Core repository operations and workspace management\r\n */\r\n\r\nimport { nanoid } from 'nanoid';\r\nimport { join } from 'node:path';\r\nimport { mkdir, rm, access } from 'node:fs/promises';\r\nimport { GitOperations, type GitCloneOptions } from '@/utils/gitOperations';\r\nimport { CacheManager } from '@/managers/CacheManager';\r\nimport type { WorkspaceManager } from '@/managers/WorkspaceManager';\r\nimport { getWorkspaceBaseDir } from '@/config/settings';\r\nimport type {\r\n  Workspace,\r\n  WorkspaceId,\r\n  GitUrl,\r\n  FilePath,\r\n  AsyncResult,\r\n  WorkspaceMetadata,\r\n  CommitHash\r\n} from '@/types/index';\r\n\r\nexport interface CloneRepositoryOptions extends GitCloneOptions {\r\n  workspaceId?: WorkspaceId;\r\n  tags?: string[];\r\n}\r\n\r\n/**\r\n * Manages repository operations and workspace lifecycle\r\n */\r\nexport class RepositoryManager {\r\n  private workspaces = new Map<WorkspaceId, Workspace>();\r\n  private gitOps: GitOperations;\r\n\r\n  constructor(\r\n    private cacheManager: CacheManager,\r\n    private workspaceManager?: WorkspaceManager // Will be injected from index.ts\r\n  ) {\r\n    this.gitOps = new GitOperations();\r\n  }\r\n\r\n  /**\r\n   * Clone a repository to a new workspace\r\n   */\r\n  async cloneRepository(\r\n    repoUrl: GitUrl,\r\n    options: CloneRepositoryOptions = {}\r\n  ): Promise<AsyncResult<Workspace>> {\r\n    try {\r\n      // Check for existing workspace with same repo and branch\r\n      const duplicateCheck = await this.checkForDuplicateWorkspace(repoUrl, options.branch);\r\n      if (duplicateCheck.success && duplicateCheck.data) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace already exists for ${repoUrl} on branch ${duplicateCheck.data.branch} (ID: ${duplicateCheck.data.id}). Use existing workspace or clean it first.`)\r\n        };\r\n      }\r\n      \r\n      // Generate workspace ID\r\n      const workspaceId = options.workspaceId || (nanoid(10) as WorkspaceId);\r\n      \r\n      // Create workspace directory\r\n      const workspaceBaseDir = getWorkspaceBaseDir();\r\n      const workspacePath = join(workspaceBaseDir, `workspace-${workspaceId}`) as FilePath;\r\n      \r\n      // Ensure base directory exists\r\n      await mkdir(workspaceBaseDir, { recursive: true });\r\n      \r\n      // Validate Git URL\r\n      if (!GitOperations.validateGitUrl(repoUrl)) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Invalid Git URL: ${repoUrl}`)\r\n        };\r\n      }\r\n\r\n      // Clone repository\r\n      const cloneResult = await this.gitOps.cloneRepository(repoUrl, workspacePath, {\r\n        ...(options.branch && { branch: options.branch }),\r\n        depth: options.depth || 1,\r\n        singleBranch: options.singleBranch !== false\r\n      });\r\n\r\n      if (!cloneResult.success) {\r\n        return cloneResult;\r\n      }\r\n\r\n      // Get actual current branch (in case Git auto-selected default branch)\r\n      const currentBranchResult = await this.gitOps.getCurrentBranch(workspacePath);\r\n      if (!currentBranchResult.success) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Failed to get current branch: ${currentBranchResult.error.message}`)\r\n        };\r\n      }\r\n      const actualBranch = currentBranchResult.data;\r\n\r\n      // Get commit hash\r\n      const commitResult = await this.gitOps.getCurrentCommitHash(workspacePath);\r\n      if (!commitResult.success) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Failed to get commit hash: ${commitResult.error.message}`)\r\n        };\r\n      }\r\n\r\n      // Calculate workspace size\r\n      const size = await this.calculateWorkspaceSize(workspacePath);\r\n\r\n      // Create workspace object\r\n      const workspace: Workspace = {\r\n        id: workspaceId,\r\n        path: workspacePath,\r\n        repoUrl,\r\n        branch: actualBranch, // Use the actual current branch\r\n        createdAt: new Date(),\r\n        lastAccessed: new Date(),\r\n        metadata: {\r\n          size,\r\n          commitHash: commitResult.data,\r\n          isActive: true,\r\n          ...(options.tags && { tags: options.tags })\r\n        }\r\n      };\r\n\r\n      // Store workspace\r\n      this.workspaces.set(workspaceId, workspace);\r\n\r\n      // Perform initial directory analysis and cache it\r\n      const analysisResult = await this.cacheManager.analyzeDirectory(workspacePath);\r\n      if (analysisResult.success) {\r\n        await this.cacheManager.setCache(\r\n          workspacePath,\r\n          analysisResult.data,\r\n          commitResult.data\r\n        );\r\n      }\r\n\r\n      return { success: true, data: workspace };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to clone repository: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace by ID\r\n   */\r\n  getWorkspace(workspaceId: WorkspaceId): Workspace | null {\r\n    const workspace = this.workspaces.get(workspaceId);\r\n    if (workspace) {\r\n      // Update last accessed time\r\n      workspace.lastAccessed = new Date();\r\n      this.workspaces.set(workspaceId, workspace);\r\n    }\r\n    return workspace || null;\r\n  }\r\n\r\n  /**\r\n   * List all workspaces\r\n   */\r\n  listWorkspaces(): Workspace[] {\r\n    return Array.from(this.workspaces.values()).sort(\r\n      (a, b) => b.lastAccessed.getTime() - a.lastAccessed.getTime()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Load all workspaces from persistent storage into memory\r\n   */\r\n  async loadAllWorkspacesFromStorage(): Promise<AsyncResult<void>> {\r\n    try {\r\n      if (!this.workspaceManager) {\r\n        return { success: true, data: undefined };\r\n      }\r\n\r\n      const allWorkspacesResult = await this.workspaceManager.getAllWorkspaces();\r\n      if (!allWorkspacesResult.success) {\r\n        return allWorkspacesResult;\r\n      }\r\n\r\n      // Load all workspaces into memory\r\n      for (const workspace of allWorkspacesResult.data) {\r\n        this.workspaces.set(workspace.id, workspace);\r\n      }\r\n\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to load workspaces from storage: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get active workspaces only\r\n   */\r\n  getActiveWorkspaces(): Workspace[] {\r\n    return this.listWorkspaces().filter(ws => ws.metadata?.isActive);\r\n  }\r\n\r\n  /**\r\n   * Update workspace metadata\r\n   */\r\n  async updateWorkspace(\r\n    workspaceId: WorkspaceId,\r\n    updates: Partial<Pick<Workspace, 'branch'>> & {\r\n      metadata?: Partial<WorkspaceMetadata>;\r\n    }\r\n  ): Promise<AsyncResult<Workspace>> {\r\n    try {\r\n      const workspace = this.workspaces.get(workspaceId);\r\n      if (!workspace) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspaceId} not found`)\r\n        };\r\n      }\r\n\r\n      // Update workspace\r\n      const updatedWorkspace: Workspace = {\r\n        ...workspace,\r\n        ...updates,\r\n        lastAccessed: new Date(),\r\n        metadata: {\r\n          ...workspace.metadata,\r\n          ...updates.metadata\r\n        } as WorkspaceMetadata\r\n      };\r\n\r\n      this.workspaces.set(workspaceId, updatedWorkspace);\r\n      return { success: true, data: updatedWorkspace };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to update workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Switch to a different branch\r\n   */\r\n  async switchBranch(\r\n    workspaceId: WorkspaceId,\r\n    branchName: string\r\n  ): Promise<AsyncResult<void>> {\r\n    try {\r\n      const workspace = this.getWorkspace(workspaceId);\r\n      if (!workspace) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspaceId} not found`)\r\n        };\r\n      }\r\n\r\n      // Switch branch using git operations\r\n      const switchResult = await this.gitOps.switchBranch(workspace.path, branchName);\r\n      if (!switchResult.success) {\r\n        return switchResult;\r\n      }\r\n\r\n      // Update workspace branch\r\n      await this.updateWorkspace(workspaceId, { branch: branchName });\r\n\r\n      // Invalidate cache since branch changed\r\n      await this.cacheManager.invalidateCache(workspace.path);\r\n\r\n      return { success: true, data: undefined };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to switch branch: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pull latest changes\r\n   */\r\n  async pullChanges(workspaceId: WorkspaceId): Promise<AsyncResult<void>> {\r\n    try {\r\n      const workspace = this.getWorkspace(workspaceId);\r\n      if (!workspace) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspaceId} not found`)\r\n        };\r\n      }\r\n\r\n      // Pull changes\r\n      const pullResult = await this.gitOps.pullChanges(workspace.path);\r\n      if (!pullResult.success) {\r\n        return pullResult;\r\n      }\r\n\r\n      // Update commit hash\r\n      const commitResult = await this.gitOps.getCurrentCommitHash(workspace.path);\r\n      if (commitResult.success) {\r\n        await this.updateWorkspace(workspaceId, {\r\n          metadata: { commitHash: commitResult.data }\r\n        });\r\n\r\n        // Invalidate cache since content changed\r\n        await this.cacheManager.invalidateCache(workspace.path);\r\n      }\r\n\r\n      return { success: true, data: undefined };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to pull changes: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up workspace\r\n   */\r\n  async cleanupWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<void>> {\r\n    try {\r\n      let workspace = this.workspaces.get(workspaceId);\r\n      \r\n      // If not in memory, try to load from WorkspaceManager\r\n      if (!workspace && this.workspaceManager) {\r\n        const loadResult = await this.workspaceManager.loadWorkspace(workspaceId);\r\n        if (loadResult.success) {\r\n          workspace = loadResult.data;\r\n        }\r\n      }\r\n      \r\n      // If still not found, try to construct path based on workspace ID\r\n      if (!workspace) {\r\n        const workspaceBaseDir = getWorkspaceBaseDir();\r\n        const workspacePath = join(workspaceBaseDir, `workspace-${workspaceId}`) as FilePath;\r\n        \r\n        // Check if directory exists\r\n        try {\r\n          await access(workspacePath);\r\n          // Directory exists, create a minimal workspace object for cleanup\r\n          workspace = {\r\n            id: workspaceId,\r\n            path: workspacePath,\r\n            repoUrl: 'unknown' as GitUrl,\r\n            branch: 'unknown',\r\n            createdAt: new Date(),\r\n            lastAccessed: new Date()\r\n          };\r\n        } catch {\r\n          return {\r\n            success: false,\r\n            error: new Error(`Workspace ${workspaceId} not found in memory, persistent storage, or file system`)\r\n          };\r\n        }\r\n      }\r\n\r\n      // Remove workspace directory\r\n      try {\r\n        await access(workspace.path);\r\n        await rm(workspace.path, { recursive: true, force: true });\r\n      } catch (error) {\r\n        // Log warning but don't fail - directory might already be gone\r\n        console.warn(`Warning: Could not remove directory ${workspace.path}:`, error);\r\n      }\r\n\r\n      // Remove from memory if it was there\r\n      this.workspaces.delete(workspaceId);\r\n\r\n      return { success: true, data: undefined };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to cleanup workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up all inactive workspaces\r\n   */\r\n  async cleanupInactiveWorkspaces(): Promise<AsyncResult<number>> {\r\n    try {\r\n      let cleanedCount = 0;\r\n      \r\n      // Get workspaces from WorkspaceManager if available, otherwise use in-memory\r\n      let workspaces: Workspace[] = [];\r\n      \r\n      if (this.workspaceManager) {\r\n        const allWorkspacesResult = await this.workspaceManager.getAllWorkspaces();\r\n        if (allWorkspacesResult.success) {\r\n          workspaces = allWorkspacesResult.data.filter(ws => !ws.metadata?.isActive);\r\n        } else {\r\n          workspaces = this.listWorkspaces().filter(ws => !ws.metadata?.isActive);\r\n        }\r\n      } else {\r\n        workspaces = this.listWorkspaces().filter(ws => !ws.metadata?.isActive);\r\n      }\r\n\r\n      for (const workspace of workspaces) {\r\n        const result = await this.cleanupWorkspace(workspace.id);\r\n        if (result.success) {\r\n          cleanedCount++;\r\n        }\r\n      }\r\n\r\n      return { success: true, data: cleanedCount };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to cleanup inactive workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Git operations instance for a workspace\r\n   */\r\n  getGitOperations(workspacePath: FilePath): GitOperations {\r\n    return new GitOperations(workspacePath);\r\n  }\r\n\r\n  /**\r\n   * Calculate total size of workspace directory\r\n   */\r\n  private async calculateWorkspaceSize(directoryPath: FilePath): Promise<number> {\r\n    try {\r\n      const analysisResult = await this.cacheManager.analyzeDirectory(directoryPath);\r\n      if (analysisResult.success) {\r\n        // Estimate size based on file count (rough approximation)\r\n        return analysisResult.data.fileCount * 1024; // 1KB average per file\r\n      }\r\n      return 0;\r\n    } catch {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check for existing workspace with same repository and branch\r\n   */\r\n  private async checkForDuplicateWorkspace(\r\n    repoUrl: GitUrl, \r\n    targetBranch?: string\r\n  ): Promise<AsyncResult<Workspace | null>> {\r\n    try {\r\n      // Skip duplicate check if no WorkspaceManager is available\r\n      if (!this.workspaceManager) {\r\n        return { success: true, data: null };\r\n      }\r\n      \r\n      const existingWorkspacesResult = await this.workspaceManager.getAllWorkspaces();\r\n      if (!existingWorkspacesResult.success) {\r\n        return existingWorkspacesResult;\r\n      }\r\n      \r\n      const existingWorkspaces = existingWorkspacesResult.data;\r\n      \r\n      // Find duplicate workspace\r\n      for (const workspace of existingWorkspaces) {\r\n        // Check if same repository URL\r\n        if (workspace.repoUrl === repoUrl) {\r\n          // If no target branch specified, check if we can get the default branch\r\n          if (!targetBranch) {\r\n            // For auto-detect case, we'll skip duplicate check since we don't know the target branch yet\r\n            continue;\r\n          }\r\n          \r\n          // Check if same branch\r\n          if (workspace.branch === targetBranch) {\r\n            // Additional check: see if it's the same commit (to avoid duplicate work)\r\n            try {\r\n              const currentCommitResult = await this.gitOps.getCurrentCommitHash(workspace.path);\r\n              if (currentCommitResult.success && workspace.metadata?.commitHash === currentCommitResult.data) {\r\n                return { success: true, data: workspace };\r\n              }\r\n            } catch {\r\n              // If we can't check commit (e.g., directory doesn't exist), still consider it a duplicate\r\n              return { success: true, data: workspace };\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      return { success: true, data: null };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to check for duplicate workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace statistics\r\n   */\r\n  getWorkspaceStats(): {\r\n    total: number;\r\n    active: number;\r\n    inactive: number;\r\n    totalSize: number;\r\n  } {\r\n    const all = this.listWorkspaces();\r\n    const active = all.filter(ws => ws.metadata?.isActive);\r\n    const totalSize = all.reduce((sum, ws) => sum + (ws.metadata?.size || 0), 0);\r\n\r\n    return {\r\n      total: all.length,\r\n      active: active.length,\r\n      inactive: all.length - active.length,\r\n      totalSize\r\n    };\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/managers/WorkspaceManager.ts"],"sourcesContent":["/**\r\n * Workspace Manager - Persistent workspace management\r\n */\r\n\r\nimport { writeFile, readFile, stat } from 'node:fs/promises';\r\nimport { join } from 'node:path';\r\nimport { getWorkspaceBaseDir } from '@/config/settings';\r\nimport type {\r\n  Workspace,\r\n  WorkspaceId,\r\n  FilePath,\r\n  AsyncResult\r\n} from '@/types/index';\r\n\r\ninterface WorkspaceIndex {\r\n  workspaces: Record<WorkspaceId, Workspace>;\r\n  lastUpdated: string;\r\n  version: string;\r\n}\r\n\r\n/**\r\n * Manages workspace persistence and state\r\n */\r\nexport class WorkspaceManager {\r\n  private readonly workspaceIndexPath: FilePath;\r\n  private workspaceIndex: WorkspaceIndex;\r\n\r\n  constructor() {\r\n    const workspaceBaseDir = getWorkspaceBaseDir();\r\n    this.workspaceIndexPath = join(workspaceBaseDir, '.workspace-index.json') as FilePath;\r\n    this.workspaceIndex = {\r\n      workspaces: {},\r\n      lastUpdated: new Date().toISOString(),\r\n      version: '1.0.0'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize workspace manager (load existing workspaces)\r\n   */\r\n  async initialize(): Promise<AsyncResult<void>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to initialize workspace manager: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save workspace to persistent storage\r\n   */\r\n  async saveWorkspace(workspace: Workspace): Promise<AsyncResult<void>> {\r\n    try {\r\n      this.workspaceIndex.workspaces[workspace.id] = workspace;\r\n      this.workspaceIndex.lastUpdated = new Date().toISOString();\r\n      \r\n      await this.saveWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to save workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load workspace from persistent storage\r\n   */\r\n  async loadWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<Workspace>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      \r\n      const workspace = this.workspaceIndex.workspaces[workspaceId];\r\n      if (!workspace) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspaceId} not found`)\r\n        };\r\n      }\r\n\r\n      // Update last accessed time\r\n      workspace.lastAccessed = new Date();\r\n      await this.saveWorkspace(workspace);\r\n\r\n      return { success: true, data: workspace };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to load workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all workspaces from persistent storage\r\n   */\r\n  async getAllWorkspaces(): Promise<AsyncResult<Workspace[]>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      \r\n      const workspaces = Object.values(this.workspaceIndex.workspaces)\r\n        .sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime());\r\n\r\n      return { success: true, data: workspaces };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to get all workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete workspace from persistent storage\r\n   */\r\n  async deleteWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<void>> {\r\n    try {\r\n      delete this.workspaceIndex.workspaces[workspaceId];\r\n      this.workspaceIndex.lastUpdated = new Date().toISOString();\r\n      \r\n      await this.saveWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to delete workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update workspace in persistent storage\r\n   */\r\n  async updateWorkspace(workspace: Workspace): Promise<AsyncResult<void>> {\r\n    try {\r\n      if (!this.workspaceIndex.workspaces[workspace.id]) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspace.id} not found`)\r\n        };\r\n      }\r\n\r\n      return await this.saveWorkspace(workspace);\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to update workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if workspace exists in storage\r\n   */\r\n  async workspaceExists(workspaceId: WorkspaceId): Promise<boolean> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      return workspaceId in this.workspaceIndex.workspaces;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace statistics\r\n   */\r\n  async getWorkspaceStats(): Promise<AsyncResult<{\r\n    total: number;\r\n    active: number;\r\n    inactive: number;\r\n    totalSize: number;\r\n    oldestAccess: Date | null;\r\n    newestAccess: Date | null;\r\n  }>> {\r\n    try {\r\n      const result = await this.getAllWorkspaces();\r\n      if (!result.success) {\r\n        return result;\r\n      }\r\n\r\n      const workspaces = result.data;\r\n      const active = workspaces.filter(ws => ws.metadata?.isActive);\r\n      const totalSize = workspaces.reduce((sum, ws) => sum + (ws.metadata?.size || 0), 0);\r\n      \r\n      const accessTimes = workspaces.map(ws => new Date(ws.lastAccessed));\r\n      const oldestAccess = accessTimes.length > 0 ? new Date(Math.min(...accessTimes.map(d => d.getTime()))) : null;\r\n      const newestAccess = accessTimes.length > 0 ? new Date(Math.max(...accessTimes.map(d => d.getTime()))) : null;\r\n\r\n      return {\r\n        success: true,\r\n        data: {\r\n          total: workspaces.length,\r\n          active: active.length,\r\n          inactive: workspaces.length - active.length,\r\n          totalSize,\r\n          oldestAccess,\r\n          newestAccess\r\n        }\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to get workspace stats: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup old workspaces (mark as inactive or delete)\r\n   */\r\n  async cleanupOldWorkspaces(maxAgeHours: number = 24 * 7): Promise<AsyncResult<number>> {\r\n    try {\r\n      const result = await this.getAllWorkspaces();\r\n      if (!result.success) {\r\n        return result;\r\n      }\r\n\r\n      const cutoffTime = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000);\r\n      let cleanedCount = 0;\r\n\r\n      for (const workspace of result.data) {\r\n        if (new Date(workspace.lastAccessed) < cutoffTime && workspace.metadata?.isActive) {\r\n          workspace.metadata.isActive = false;\r\n          await this.saveWorkspace(workspace);\r\n          cleanedCount++;\r\n        }\r\n      }\r\n\r\n      return { success: true, data: cleanedCount };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to cleanup old workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load workspace index from disk\r\n   */\r\n  private async loadWorkspaceIndex(): Promise<void> {\r\n    try {\r\n      await stat(this.workspaceIndexPath);\r\n      const content = await readFile(this.workspaceIndexPath, 'utf-8');\r\n      this.workspaceIndex = JSON.parse(content);\r\n      \r\n      // Convert date strings back to Date objects\r\n      Object.values(this.workspaceIndex.workspaces).forEach(workspace => {\r\n        workspace.createdAt = new Date(workspace.createdAt);\r\n        workspace.lastAccessed = new Date(workspace.lastAccessed);\r\n      });\r\n    } catch {\r\n      // File doesn't exist or is corrupted, start with empty index\r\n      this.workspaceIndex = {\r\n        workspaces: {},\r\n        lastUpdated: new Date().toISOString(),\r\n        version: '1.0.0'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save workspace index to disk\r\n   */\r\n  private async saveWorkspaceIndex(): Promise<void> {\r\n    const content = JSON.stringify(this.workspaceIndex, null, 2);\r\n    await writeFile(this.workspaceIndexPath, content, 'utf-8');\r\n  }\r\n\r\n  /**\r\n   * Get workspace index file path\r\n   */\r\n  getIndexPath(): FilePath {\r\n    return this.workspaceIndexPath;\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1464, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/managers/CacheManager.ts"],"sourcesContent":["/**\n * Cache Manager for directory analysis and AI cache files\n */\n\nimport { readFile, writeFile, access, stat, mkdir } from 'node:fs/promises';\nimport { createHash } from 'node:crypto';\nimport { join, dirname } from 'node:path';\nimport { glob } from 'glob';\nimport type { \n  CacheData, \n  DirectoryAnalysis, \n  FilePath, \n  CommitHash, \n  FileTreeNode, \n  WorkspaceId,\n  AsyncResult\n} from '@/types/index';\n\nexport interface CacheOptions {\n  expiryDays: number;\n  maxCacheSize: number;\n  includePatterns: string[];\n  excludePatterns: string[];\n}\n\n/**\n * Manages caching of directory analysis and AI-generated insights\n */\nexport class CacheManager {\n  private readonly cacheFileName = '.ai-cache';\n  private readonly cacheVersion = '1.0.0';\n\n  constructor(private readonly options: CacheOptions) {}\n\n  /**\n   * Get cache data for a directory\n   */\n  async getCache(directoryPath: FilePath): Promise<AsyncResult<CacheData | null>> {\n    try {\n      const cacheFilePath = join(directoryPath, this.cacheFileName);\n      \n      // Check if cache file exists\n      try {\n        await access(cacheFilePath);\n      } catch {\n        return { success: true, data: null };\n      }\n\n      const cacheContent = await readFile(cacheFilePath, 'utf-8');\n      const cacheData: CacheData = JSON.parse(cacheContent);\n\n      // Validate cache version\n      if (cacheData.version !== this.cacheVersion) {\n        return { success: true, data: null };\n      }\n\n      // Check if cache is expired\n      const isExpired = this.isCacheExpired(cacheData.lastUpdated);\n      if (isExpired) {\n        return { success: true, data: null };\n      }\n\n      // Verify directory hasn't changed\n      const currentHash = await this.calculateDirectoryHash(directoryPath);\n      if (currentHash.success && currentHash.data !== cacheData.directoryHash) {\n        return { success: true, data: null };\n      }\n\n      return { success: true, data: cacheData };\n    } catch (error) {\n      return { \n        success: false, \n        error: new Error(`Failed to read cache: ${error}`) \n      };\n    }\n  }\n\n  /**\n   * Save cache data for a directory\n   */\n  async setCache(\n    directoryPath: FilePath, \n    analysis: DirectoryAnalysis, \n    commitHash: CommitHash\n  ): Promise<AsyncResult<void>> {\n    try {\n      const directoryHashResult = await this.calculateDirectoryHash(directoryPath);\n      if (!directoryHashResult.success) {\n        return directoryHashResult;\n      }\n\n      const cacheData: CacheData = {\n        lastCommitHash: commitHash,\n        directoryHash: directoryHashResult.data,\n        lastUpdated: new Date(),\n        analysis,\n        version: this.cacheVersion\n      };\n\n      const cacheFilePath = join(directoryPath, this.cacheFileName);\n      const cacheContent = JSON.stringify(cacheData, null, 2);\n      \n      await writeFile(cacheFilePath, cacheContent, 'utf-8');\n      \n      return { success: true, data: undefined };\n    } catch (error) {\n      return { \n        success: false, \n        error: new Error(`Failed to save cache: ${error}`) \n      };\n    }\n  }\n\n  /**\n   * Invalidate cache for a directory\n   */\n  async invalidateCache(directoryPath: FilePath): Promise<AsyncResult<void>> {\n    try {\n      const cacheFilePath = join(directoryPath, this.cacheFileName);\n      \n      try {\n        await access(cacheFilePath);\n        // If file exists, delete it by writing empty content\n        await writeFile(cacheFilePath, '', 'utf-8');\n      } catch {\n        // File doesn't exist, nothing to do\n      }\n\n      return { success: true, data: undefined };\n    } catch (error) {\n      return { \n        success: false, \n        error: new Error(`Failed to invalidate cache: ${error}`) \n      };\n    }\n  }\n\n  /**\n   * Analyze directory structure and create file tree\n   */\n  async analyzeDirectory(directoryPath: FilePath): Promise<AsyncResult<DirectoryAnalysis>> {\n    try {\n      const files = await this.getDirectoryFiles(directoryPath);\n      const structure = await this.buildFileTree(directoryPath, files);\n      const languages = this.detectLanguages(files);\n      \n      const analysis: DirectoryAnalysis = {\n        fileCount: files.length,\n        languages,\n        structure\n        // AI summary and improvements will be added by Claude integration\n      };\n\n      return { success: true, data: analysis };\n    } catch (error) {\n      return { \n        success: false, \n        error: new Error(`Failed to analyze directory: ${error}`) \n      };\n    }\n  }\n\n  /**\n   * Get all files in directory matching patterns\n   */\n  private async getDirectoryFiles(directoryPath: FilePath): Promise<string[]> {\n    const includePatterns = this.options.includePatterns.length > 0 \n      ? this.options.includePatterns \n      : ['**/*'];\n\n    const allFiles: string[] = [];\n    \n    for (const pattern of includePatterns) {\n      const files = await glob(pattern, {\n        cwd: directoryPath,\n        ignore: this.options.excludePatterns,\n        nodir: true,\n        dot: false\n      });\n      allFiles.push(...files);\n    }\n\n    // Remove duplicates and sort\n    return [...new Set(allFiles)].sort();\n  }\n\n  /**\n   * Build file tree structure\n   */\n  private async buildFileTree(basePath: FilePath, files: string[]): Promise<FileTreeNode[]> {\n    const tree: Map<string, FileTreeNode> = new Map();\n    const rootNodes: FileTreeNode[] = [];\n\n    for (const file of files) {\n      const parts = file.split('/');\n      let currentPath = '';\n      let currentLevel = rootNodes;\n      let parentMap = tree;\n\n      for (let i = 0; i < parts.length; i++) {\n        const part = parts[i]!;\n        const isFile = i === parts.length - 1;\n        currentPath = currentPath ? `${currentPath}/${part}` : part;\n        const fullPath = join(basePath, currentPath) as FilePath;\n\n        if (!parentMap.has(currentPath)) {\n          const node: FileTreeNode = {\n            name: part,\n            path: fullPath,\n            type: isFile ? 'file' : 'directory',\n            ...(isFile ? {} : { children: [] })\n          };\n\n          // Add file metadata for files\n          if (isFile) {\n            try {\n              const stats = await stat(fullPath);\n              node.size = stats.size;\n              node.lastModified = stats.mtime;\n              node.mimeType = this.getMimeType(part);\n            } catch {\n              // Ignore stat errors\n            }\n          }\n\n          parentMap.set(currentPath, node);\n          currentLevel.push(node);\n        }\n\n        const currentNode = parentMap.get(currentPath)!;\n        if (!isFile && currentNode.children) {\n          currentLevel = currentNode.children;\n        }\n      }\n    }\n\n    return rootNodes;\n  }\n\n  /**\n   * Detect programming languages from file extensions\n   */\n  private detectLanguages(files: string[]): string[] {\n    const extensionMap: Record<string, string> = {\n      '.js': 'JavaScript',\n      '.ts': 'TypeScript',\n      '.jsx': 'React',\n      '.tsx': 'React TypeScript',\n      '.py': 'Python',\n      '.java': 'Java',\n      '.cpp': 'C++',\n      '.c': 'C',\n      '.cs': 'C#',\n      '.go': 'Go',\n      '.rs': 'Rust',\n      '.php': 'PHP',\n      '.rb': 'Ruby',\n      '.swift': 'Swift',\n      '.kt': 'Kotlin',\n      '.scala': 'Scala',\n      '.sh': 'Shell',\n      '.yml': 'YAML',\n      '.yaml': 'YAML',\n      '.json': 'JSON',\n      '.xml': 'XML',\n      '.html': 'HTML',\n      '.css': 'CSS',\n      '.scss': 'SCSS',\n      '.sass': 'Sass',\n      '.md': 'Markdown',\n      '.sql': 'SQL'\n    };\n\n    const languages = new Set<string>();\n    \n    for (const file of files) {\n      const ext = file.substring(file.lastIndexOf('.'));\n      const language = extensionMap[ext.toLowerCase()];\n      if (language) {\n        languages.add(language);\n      }\n    }\n\n    return Array.from(languages).sort();\n  }\n\n  /**\n   * Get MIME type for file extension\n   */\n  private getMimeType(filename: string): string {\n    const ext = filename.substring(filename.lastIndexOf('.'));\n    const mimeMap: Record<string, string> = {\n      '.js': 'application/javascript',\n      '.ts': 'application/typescript',\n      '.json': 'application/json',\n      '.html': 'text/html',\n      '.css': 'text/css',\n      '.md': 'text/markdown',\n      '.txt': 'text/plain',\n      '.py': 'text/x-python',\n      '.java': 'text/x-java-source',\n      '.cpp': 'text/x-c++src',\n      '.c': 'text/x-csrc'\n    };\n    \n    return mimeMap[ext.toLowerCase()] || 'application/octet-stream';\n  }\n\n  /**\n   * Calculate hash of directory contents\n   */\n  private async calculateDirectoryHash(directoryPath: FilePath): Promise<AsyncResult<string>> {\n    try {\n      const files = await this.getDirectoryFiles(directoryPath);\n      const hash = createHash('sha256');\n      \n      // Sort files for consistent hashing\n      files.sort();\n      \n      for (const file of files) {\n        const filePath = join(directoryPath, file);\n        try {\n          const stats = await stat(filePath);\n          // Include file path, size, and modification time in hash\n          hash.update(`${file}:${stats.size}:${stats.mtime.getTime()}`);\n        } catch {\n          // Skip files that can't be accessed\n          continue;\n        }\n      }\n      \n      return { success: true, data: hash.digest('hex') };\n    } catch (error) {\n      return { \n        success: false, \n        error: new Error(`Failed to calculate directory hash: ${error}`) \n      };\n    }\n  }\n\n  /**\n   * Check if cache is expired\n   */\n  private isCacheExpired(lastUpdated: Date): boolean {\n    const expiryTime = this.options.expiryDays * 24 * 60 * 60 * 1000; // Convert days to milliseconds\n    const now = new Date().getTime();\n    const cacheTime = lastUpdated.getTime();\n    \n    return (now - cacheTime) > expiryTime;\n  }\n\n  /**\n   * Clean up expired cache files in workspace\n   */\n  async cleanupExpiredCache(workspaceId: WorkspaceId, workspacePath: FilePath): Promise<AsyncResult<number>> {\n    try {\n      let cleanedCount = 0;\n      \n      const cacheFiles = await glob(`**/${this.cacheFileName}`, {\n        cwd: workspacePath,\n        absolute: true\n      });\n\n      for (const cacheFile of cacheFiles) {\n        try {\n          const content = await readFile(cacheFile, 'utf-8');\n          const cacheData: CacheData = JSON.parse(content);\n          \n          if (this.isCacheExpired(cacheData.lastUpdated)) {\n            await writeFile(cacheFile, '', 'utf-8'); // Clear the file\n            cleanedCount++;\n          }\n        } catch {\n          // Skip invalid cache files\n          continue;\n        }\n      }\n\n      return { success: true, data: cleanedCount };\n    } catch (error) {\n      return { \n        success: false, \n        error: new Error(`Failed to cleanup expired cache: ${error}`) \n      };\n    }\n  }\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1816, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/app/api/cleanup/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { RepositoryManager } from '@/managers/RepositoryManager';\r\nimport { WorkspaceManager } from '@/managers/WorkspaceManager';\r\nimport { CacheManager } from '@/managers/CacheManager';\r\nimport type { WorkspaceId } from '@/types/index';\r\n\r\nconst cacheManager = new CacheManager({\r\n  expiryDays: 7,\r\n  maxCacheSize: 100 * 1024 * 1024, // 100MB\r\n  includePatterns: ['**/*.ts', '**/*.js', '**/*.json', '**/*.md', '**/*.yml', '**/*.yaml'],\r\n  excludePatterns: ['node_modules/**', 'dist/**', '.git/**', '**/.DS_Store']\r\n});\r\nconst workspaceManager = new WorkspaceManager();\r\nconst repositoryManager = new RepositoryManager(cacheManager, workspaceManager);\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const { workspaceId, all = false, force = false } = await request.json();\r\n\r\n    // Initialize workspace manager\r\n    const initResult = await workspaceManager.initialize();\r\n    if (!initResult.success) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to initialize workspace manager', details: initResult.error?.message },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    if (workspaceId) {\r\n      // Clean specific workspace\r\n      const cleanResult = await repositoryManager.cleanupWorkspace(workspaceId as WorkspaceId);\r\n      if (!cleanResult.success) {\r\n        return NextResponse.json(\r\n          { error: 'Failed to clean workspace', details: cleanResult.error?.message },\r\n          { status: 500 }\r\n        );\r\n      }\r\n\r\n      // Remove from persistent storage\r\n      const deleteResult = await workspaceManager.deleteWorkspace(workspaceId as WorkspaceId);\r\n      if (!deleteResult.success) {\r\n        console.warn('Warning: Failed to remove workspace from persistent storage');\r\n      }\r\n\r\n      return NextResponse.json({\r\n        success: true,\r\n        message: `Workspace ${workspaceId} cleaned successfully`,\r\n        cleanedWorkspaces: 1\r\n      });\r\n\r\n    } else if (all) {\r\n      if (!force) {\r\n        return NextResponse.json(\r\n          { error: 'Force flag is required for bulk cleanup operations' },\r\n          { status: 400 }\r\n        );\r\n      }\r\n\r\n      // Get all workspaces\r\n      const workspacesResult = await workspaceManager.getAllWorkspaces();\r\n      if (!workspacesResult.success) {\r\n        return NextResponse.json(\r\n          { error: 'Failed to get workspaces', details: workspacesResult.error?.message },\r\n          { status: 500 }\r\n        );\r\n      }\r\n\r\n      const allWorkspaces = workspacesResult.data;\r\n      let cleanedCount = 0;\r\n      const errors: string[] = [];\r\n\r\n      // Clean each workspace\r\n      for (const workspace of allWorkspaces) {\r\n        try {\r\n          const cleanResult = await repositoryManager.cleanupWorkspace(workspace.id);\r\n          if (cleanResult.success) {\r\n            await workspaceManager.deleteWorkspace(workspace.id);\r\n            cleanedCount++;\r\n          } else {\r\n            errors.push(`Failed to clean ${workspace.id}: ${cleanResult.error?.message}`);\r\n          }\r\n        } catch (error) {\r\n          errors.push(`Error cleaning ${workspace.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n      }\r\n\r\n      return NextResponse.json({\r\n        success: true,\r\n        message: `Cleaned ${cleanedCount}/${allWorkspaces.length} workspaces`,\r\n        cleanedWorkspaces: cleanedCount,\r\n        totalWorkspaces: allWorkspaces.length,\r\n        errors: errors.length > 0 ? errors : undefined\r\n      });\r\n\r\n    } else {\r\n      // Get workspace stats for information\r\n      const statsResult = await workspaceManager.getWorkspaceStats();\r\n      if (!statsResult.success) {\r\n        return NextResponse.json(\r\n          { error: 'Failed to get workspace stats', details: statsResult.error?.message },\r\n          { status: 500 }\r\n        );\r\n      }\r\n\r\n      const stats = statsResult.data;\r\n      return NextResponse.json({\r\n        success: true,\r\n        message: 'Specify workspaceId for single cleanup or use all=true for bulk cleanup',\r\n        stats: {\r\n          total: stats.total,\r\n          active: stats.active,\r\n          inactive: stats.inactive,\r\n          totalSizeMB: Math.round(stats.totalSize / 1024 / 1024)\r\n        }\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Error in cleanup API:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error', details: error instanceof Error ? error.message : String(error) },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}}]
}