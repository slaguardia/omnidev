{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/managers/WorkspaceManager.ts"],"sourcesContent":["/**\r\n * Workspace Manager - Persistent workspace management\r\n */\r\n\r\nimport { writeFile, readFile, stat } from 'node:fs/promises';\r\nimport { join } from 'node:path';\r\nimport { getWorkspaceBaseDir } from '@/config/settings.js';\r\nimport type {\r\n  Workspace,\r\n  WorkspaceId,\r\n  FilePath,\r\n  AsyncResult\r\n} from '@/types/index.js';\r\n\r\ninterface WorkspaceIndex {\r\n  workspaces: Record<WorkspaceId, Workspace>;\r\n  lastUpdated: string;\r\n  version: string;\r\n}\r\n\r\n/**\r\n * Manages workspace persistence and state\r\n */\r\nexport class WorkspaceManager {\r\n  private readonly workspaceIndexPath: FilePath;\r\n  private workspaceIndex: WorkspaceIndex;\r\n\r\n  constructor() {\r\n    const workspaceBaseDir = getWorkspaceBaseDir();\r\n    this.workspaceIndexPath = join(workspaceBaseDir, '.workspace-index.json') as FilePath;\r\n    this.workspaceIndex = {\r\n      workspaces: {},\r\n      lastUpdated: new Date().toISOString(),\r\n      version: '1.0.0'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize workspace manager (load existing workspaces)\r\n   */\r\n  async initialize(): Promise<AsyncResult<void>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to initialize workspace manager: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save workspace to persistent storage\r\n   */\r\n  async saveWorkspace(workspace: Workspace): Promise<AsyncResult<void>> {\r\n    try {\r\n      this.workspaceIndex.workspaces[workspace.id] = workspace;\r\n      this.workspaceIndex.lastUpdated = new Date().toISOString();\r\n      \r\n      await this.saveWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to save workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load workspace from persistent storage\r\n   */\r\n  async loadWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<Workspace>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      \r\n      const workspace = this.workspaceIndex.workspaces[workspaceId];\r\n      if (!workspace) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspaceId} not found`)\r\n        };\r\n      }\r\n\r\n      // Update last accessed time\r\n      workspace.lastAccessed = new Date();\r\n      await this.saveWorkspace(workspace);\r\n\r\n      return { success: true, data: workspace };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to load workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all workspaces from persistent storage\r\n   */\r\n  async getAllWorkspaces(): Promise<AsyncResult<Workspace[]>> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      \r\n      const workspaces = Object.values(this.workspaceIndex.workspaces)\r\n        .sort((a, b) => new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime());\r\n\r\n      return { success: true, data: workspaces };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to get all workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete workspace from persistent storage\r\n   */\r\n  async deleteWorkspace(workspaceId: WorkspaceId): Promise<AsyncResult<void>> {\r\n    try {\r\n      delete this.workspaceIndex.workspaces[workspaceId];\r\n      this.workspaceIndex.lastUpdated = new Date().toISOString();\r\n      \r\n      await this.saveWorkspaceIndex();\r\n      return { success: true, data: undefined };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to delete workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update workspace in persistent storage\r\n   */\r\n  async updateWorkspace(workspace: Workspace): Promise<AsyncResult<void>> {\r\n    try {\r\n      if (!this.workspaceIndex.workspaces[workspace.id]) {\r\n        return {\r\n          success: false,\r\n          error: new Error(`Workspace ${workspace.id} not found`)\r\n        };\r\n      }\r\n\r\n      return await this.saveWorkspace(workspace);\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to update workspace: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if workspace exists in storage\r\n   */\r\n  async workspaceExists(workspaceId: WorkspaceId): Promise<boolean> {\r\n    try {\r\n      await this.loadWorkspaceIndex();\r\n      return workspaceId in this.workspaceIndex.workspaces;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace statistics\r\n   */\r\n  async getWorkspaceStats(): Promise<AsyncResult<{\r\n    total: number;\r\n    active: number;\r\n    inactive: number;\r\n    totalSize: number;\r\n    oldestAccess: Date | null;\r\n    newestAccess: Date | null;\r\n  }>> {\r\n    try {\r\n      const result = await this.getAllWorkspaces();\r\n      if (!result.success) {\r\n        return result;\r\n      }\r\n\r\n      const workspaces = result.data;\r\n      const active = workspaces.filter(ws => ws.metadata?.isActive);\r\n      const totalSize = workspaces.reduce((sum, ws) => sum + (ws.metadata?.size || 0), 0);\r\n      \r\n      const accessTimes = workspaces.map(ws => new Date(ws.lastAccessed));\r\n      const oldestAccess = accessTimes.length > 0 ? new Date(Math.min(...accessTimes.map(d => d.getTime()))) : null;\r\n      const newestAccess = accessTimes.length > 0 ? new Date(Math.max(...accessTimes.map(d => d.getTime()))) : null;\r\n\r\n      return {\r\n        success: true,\r\n        data: {\r\n          total: workspaces.length,\r\n          active: active.length,\r\n          inactive: workspaces.length - active.length,\r\n          totalSize,\r\n          oldestAccess,\r\n          newestAccess\r\n        }\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to get workspace stats: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup old workspaces (mark as inactive or delete)\r\n   */\r\n  async cleanupOldWorkspaces(maxAgeHours: number = 24 * 7): Promise<AsyncResult<number>> {\r\n    try {\r\n      const result = await this.getAllWorkspaces();\r\n      if (!result.success) {\r\n        return result;\r\n      }\r\n\r\n      const cutoffTime = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000);\r\n      let cleanedCount = 0;\r\n\r\n      for (const workspace of result.data) {\r\n        if (new Date(workspace.lastAccessed) < cutoffTime && workspace.metadata?.isActive) {\r\n          workspace.metadata.isActive = false;\r\n          await this.saveWorkspace(workspace);\r\n          cleanedCount++;\r\n        }\r\n      }\r\n\r\n      return { success: true, data: cleanedCount };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: new Error(`Failed to cleanup old workspaces: ${error}`)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load workspace index from disk\r\n   */\r\n  private async loadWorkspaceIndex(): Promise<void> {\r\n    try {\r\n      await stat(this.workspaceIndexPath);\r\n      const content = await readFile(this.workspaceIndexPath, 'utf-8');\r\n      this.workspaceIndex = JSON.parse(content);\r\n      \r\n      // Convert date strings back to Date objects\r\n      Object.values(this.workspaceIndex.workspaces).forEach(workspace => {\r\n        workspace.createdAt = new Date(workspace.createdAt);\r\n        workspace.lastAccessed = new Date(workspace.lastAccessed);\r\n      });\r\n    } catch {\r\n      // File doesn't exist or is corrupted, start with empty index\r\n      this.workspaceIndex = {\r\n        workspaces: {},\r\n        lastUpdated: new Date().toISOString(),\r\n        version: '1.0.0'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save workspace index to disk\r\n   */\r\n  private async saveWorkspaceIndex(): Promise<void> {\r\n    const content = JSON.stringify(this.workspaceIndex, null, 2);\r\n    await writeFile(this.workspaceIndexPath, content, 'utf-8');\r\n  }\r\n\r\n  /**\r\n   * Get workspace index file path\r\n   */\r\n  getIndexPath(): FilePath {\r\n    return this.workspaceIndexPath;\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/steve/Repositories/workflow/src/app/api/workspaces/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { WorkspaceManager } from '@/managers/WorkspaceManager';\r\n\r\nconst workspaceManager = new WorkspaceManager();\r\n\r\nexport async function GET() {\r\n  try {\r\n    // Initialize workspace manager\r\n    const initResult = await workspaceManager.initialize();\r\n    if (!initResult.success) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to initialize workspace manager', details: initResult.error?.message },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // Get all workspaces\r\n    const workspacesResult = await workspaceManager.getAllWorkspaces();\r\n    if (!workspacesResult.success) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to get workspaces', details: workspacesResult.error?.message },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      workspaces: workspacesResult.data\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Error in workspaces API:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error', details: error instanceof Error ? error.message : String(error) },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,MAAM,mBAAmB,IAAI,qIAAA,CAAA,mBAAgB;AAEtC,eAAe;IACpB,IAAI;QACF,+BAA+B;QAC/B,MAAM,aAAa,MAAM,iBAAiB,UAAU;QACpD,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAA0C,SAAS,WAAW,KAAK,EAAE;YAAQ,GACtF;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,mBAAmB,MAAM,iBAAiB,gBAAgB;QAChE,IAAI,CAAC,iBAAiB,OAAO,EAAE;YAC7B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAA4B,SAAS,iBAAiB,KAAK,EAAE;YAAQ,GAC9E;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,YAAY,iBAAiB,IAAI;QACnC;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAAyB,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QAAO,GAClG;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}