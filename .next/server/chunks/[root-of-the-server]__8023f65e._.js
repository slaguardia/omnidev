module.exports = {

"[project]/.next-internal/server/app/api/cleanup/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/node:path [external] (node:path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}}),
"[externals]/node:fs/promises [external] (node:fs/promises, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:fs/promises", () => require("node:fs/promises"));

module.exports = mod;
}}),
"[externals]/node:buffer [external] (node:buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/node:events [external] (node:events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}}),
"[externals]/fs/promises [external] (fs/promises, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs/promises", () => require("fs/promises"));

module.exports = mod;
}}),
"[project]/src/utils/gitOperations.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Git operations utilities
 */ __turbopack_context__.s({
    "GitOperations": (()=>GitOperations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/simple-git/dist/esm/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
;
;
class GitOperations {
    git;
    constructor(workingDirectory){
        this.git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workingDirectory || process.cwd());
    }
    /**
   * Clone a repository to a local directory
   */ async cloneRepository(repoUrl, targetPath, options = {}) {
        try {
            // Ensure target directory exists
            await this.ensureDirectoryExists(targetPath);
            const cloneOptions = [];
            if (options.depth) {
                cloneOptions.push('--depth', options.depth.toString());
            }
            if (options.singleBranch) {
                cloneOptions.push('--single-branch');
            }
            if (options.branch) {
                cloneOptions.push('--branch', options.branch);
            }
            if (options.bare) {
                cloneOptions.push('--bare');
            }
            await this.git.clone(repoUrl, targetPath, cloneOptions);
            // Add to Git safe directories to prevent ownership issues
            await this.addToSafeDirectory(targetPath);
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to clone repository: ${error}`)
            };
        }
    }
    /**
   * Get current commit hash
   */ async getCurrentCommitHash(workspacePath) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            const log = await git.log([
                '-1',
                '--format=%H'
            ]);
            const hash = log.latest?.hash;
            if (!hash) {
                return {
                    success: false,
                    error: new Error('No commits found in repository')
                };
            }
            return {
                success: true,
                data: hash
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get commit hash: ${error}`)
            };
        }
    }
    /**
   * Get current branch name
   */ async getCurrentBranch(workspacePath) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            // Try to add to safe directory first if we get an ownership error
            try {
                const status = await git.status();
                const currentBranch = status.current;
                if (!currentBranch) {
                    return {
                        success: false,
                        error: new Error('No current branch found (detached HEAD?)')
                    };
                }
                return {
                    success: true,
                    data: currentBranch
                };
            } catch (error) {
                // If it's an ownership error, try adding to safe directory and retry
                if (String(error).includes('dubious ownership')) {
                    await this.addToSafeDirectory(workspacePath);
                    // Retry after adding to safe directory
                    const status = await git.status();
                    const currentBranch = status.current;
                    if (!currentBranch) {
                        return {
                            success: false,
                            error: new Error('No current branch found (detached HEAD?)')
                        };
                    }
                    return {
                        success: true,
                        data: currentBranch
                    };
                }
                // Re-throw if it's not an ownership error
                throw error;
            }
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get current branch: ${error}`)
            };
        }
    }
    /**
   * Get commit information
   */ async getCommitInfo(workspacePath, commitHash) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            const log = await git.log([
                '-1',
                commitHash || 'HEAD'
            ]);
            const commit = log.latest;
            if (!commit) {
                return {
                    success: false,
                    error: new Error('Commit not found')
                };
            }
            const info = {
                hash: commit.hash,
                message: commit.message,
                author: `${commit.author_name} <${commit.author_email}>`,
                date: new Date(commit.date)
            };
            return {
                success: true,
                data: info
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get commit info: ${error}`)
            };
        }
    }
    /**
   * Get all branches
   */ async getBranches(workspacePath) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            const branches = await git.branch([
                '--all'
            ]);
            const branchInfo = [];
            for (const [branchName, branchData] of Object.entries(branches.branches)){
                if (branchName === 'HEAD') continue;
                branchInfo.push({
                    name: branchName,
                    isRemote: branchName.startsWith('remotes/'),
                    isCurrent: branchData.current,
                    commitHash: branchData.commit
                });
            }
            return {
                success: true,
                data: branchInfo
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get branches: ${error}`)
            };
        }
    }
    /**
   * Switch to a different branch
   */ async switchBranch(workspacePath, branchName) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            // Check if branch exists locally
            const branches = await git.branch();
            const localBranches = Object.keys(branches.branches);
            if (localBranches.includes(branchName)) {
                // Switch to existing local branch
                await git.checkout(branchName);
            } else {
                // Create and switch to new branch from remote
                await git.checkoutLocalBranch(branchName);
            }
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to switch branch: ${error}`)
            };
        }
    }
    /**
   * Pull latest changes from remote
   */ async pullChanges(workspacePath) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            await git.pull();
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to pull changes: ${error}`)
            };
        }
    }
    /**
   * Check if directory is a Git repository
   */ async isGitRepository(directoryPath) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(directoryPath);
            await git.status();
            return true;
        } catch  {
            return false;
        }
    }
    /**
   * Get repository status
   */ async getStatus(workspacePath) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            const status = await git.status();
            return {
                success: true,
                data: {
                    isClean: status.isClean(),
                    staged: status.staged,
                    modified: status.modified,
                    untracked: status.not_added
                }
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get status: ${error}`)
            };
        }
    }
    /**
   * Get repository remote URL
   */ async getRemoteUrl(workspacePath, remoteName = 'origin') {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            const remotes = await git.getRemotes(true);
            const remote = remotes.find((r)=>r.name === remoteName);
            if (!remote?.refs?.fetch) {
                return {
                    success: false,
                    error: new Error(`Remote '${remoteName}' not found`)
                };
            }
            return {
                success: true,
                data: remote.refs.fetch
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get remote URL: ${error}`)
            };
        }
    }
    /**
   * Clean workspace (remove untracked files and directories)
   */ async cleanWorkspace(workspacePath, force = false) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            if (force) {
                await git.clean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CleanOptions"].FORCE + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CleanOptions"].RECURSIVE);
            } else {
                await git.clean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CleanOptions"].DRY_RUN + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CleanOptions"].RECURSIVE);
            }
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to clean workspace: ${error}`)
            };
        }
    }
    /**
   * Reset workspace to last commit
   */ async resetWorkspace(workspacePath, hard = false) {
        try {
            const git = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$git$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleGit"])(workspacePath);
            if (hard) {
                await git.reset([
                    '--hard',
                    'HEAD'
                ]);
            } else {
                await git.reset([
                    'HEAD'
                ]);
            }
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to reset workspace: ${error}`)
            };
        }
    }
    /**
   * Ensure directory exists
   */ async ensureDirectoryExists(directoryPath) {
        try {
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["stat"])(directoryPath);
        } catch  {
            // Directory doesn't exist, create it
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["mkdir"])(directoryPath, {
                recursive: true
            });
        }
    }
    /**
   * Validate Git URL format
   */ static validateGitUrl(url) {
        // Basic Git URL validation
        const gitUrlPatterns = [
            /^https?:\/\/.+\.git$/i,
            /^git@.+:.+\.git$/i,
            /^ssh:\/\/git@.+\/.+\.git$/i,
            /^https?:\/\/.+\/.+$/i // HTTPS without .git
        ];
        return gitUrlPatterns.some((pattern)=>pattern.test(url));
    }
    /**
   * Extract repository name from URL
   */ static extractRepoName(url) {
        const urlStr = url.toString();
        const parts = urlStr.split('/');
        const lastPart = parts[parts.length - 1] || '';
        // Remove .git extension if present
        return lastPart.replace(/\.git$/, '') || 'unknown-repo';
    }
    /**
   * Generate safe directory name from repository URL
   */ static generateSafeDirName(url, branch) {
        const repoName = GitOperations.extractRepoName(url);
        const safeName = repoName.replace(/[^a-zA-Z0-9-_]/g, '-');
        if (branch && branch !== 'main' && branch !== 'master') {
            return `${safeName}-${branch.replace(/[^a-zA-Z0-9-_]/g, '-')}`;
        }
        return safeName;
    }
    /**
   * Add directory to Git safe directories to prevent ownership issues
   */ async addToSafeDirectory(directoryPath) {
        try {
            await this.git.raw([
                'config',
                '--global',
                '--add',
                'safe.directory',
                directoryPath
            ]);
        } catch (error) {
            // Non-fatal error - log but don't fail the operation
            console.warn(`Warning: Could not add ${directoryPath} to Git safe directories:`, error);
        }
    }
}
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[project]/src/config/settings.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Configuration management for GitLab Claude Manager
 */ __turbopack_context__.s({
    "appConfig": (()=>appConfig),
    "claudeConfig": (()=>claudeConfig),
    "getCacheDir": (()=>getCacheDir),
    "getWorkspaceBaseDir": (()=>getWorkspaceBaseDir),
    "gitlabConfig": (()=>gitlabConfig),
    "initializeConfig": (()=>initializeConfig),
    "isDevelopment": (()=>isDevelopment),
    "isProduction": (()=>isProduction),
    "loggingConfig": (()=>loggingConfig),
    "securityConfig": (()=>securityConfig),
    "validateConfig": (()=>validateConfig),
    "workspaceConfig": (()=>workspaceConfig)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
;
;
// Load environment variables
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["config"])();
/**
 * Get environment variable with type safety and default value
 */ function getEnvVar(key, defaultValue, parser) {
    const value = process.env[key];
    if (value === undefined) {
        if (defaultValue !== undefined) {
            return defaultValue;
        }
        throw new Error(`Required environment variable ${key} is not set`);
    }
    return parser ? parser(value) : value;
}
/**
 * Parse boolean from string
 */ function parseBoolean(value) {
    return value.toLowerCase() === 'true' || value === '1';
}
/**
 * Parse number from string
 */ function parseNumber(value) {
    const num = parseInt(value, 10);
    if (isNaN(num)) {
        throw new Error(`Invalid number value: ${value}`);
    }
    return num;
}
/**
 * Parse comma-separated string to array
 */ function parseStringArray(value) {
    return value.split(',').map((s)=>s.trim()).filter((s)=>s.length > 0);
}
const gitlabConfig = {
    url: getEnvVar('GITLAB_URL', 'https://gitlab.com'),
    token: getEnvVar('GITLAB_TOKEN'),
    allowedHosts: getEnvVar('ALLOWED_GITLAB_HOSTS', [
        'gitlab.com'
    ], parseStringArray)
};
const claudeConfig = {
    apiKey: getEnvVar('CLAUDE_API_KEY'),
    codeCliPath: getEnvVar('CLAUDE_CODE_PATH', 'claude-code'),
    maxTokens: getEnvVar('CLAUDE_MAX_TOKENS', 4000, parseNumber),
    defaultTemperature: getEnvVar('CLAUDE_TEMPERATURE', 0.3, parseFloat)
};
const workspaceConfig = {
    maxSizeMB: getEnvVar('MAX_WORKSPACE_SIZE_MB', 500, parseNumber),
    maxConcurrent: getEnvVar('MAX_CONCURRENT_WORKSPACES', 3, parseNumber),
    cacheExpiryDays: getEnvVar('CACHE_EXPIRY_DAYS', 7, parseNumber),
    tempDirPrefix: getEnvVar('TEMP_DIR_PREFIX', 'gitlab-claude-')
};
const securityConfig = {
    allowedGitLabHosts: getEnvVar('ALLOWED_GITLAB_HOSTS', [
        'gitlab.com'
    ], parseStringArray),
    maxWorkspaceSize: getEnvVar('MAX_WORKSPACE_SIZE_MB', 500, parseNumber) * 1024 * 1024,
    enableSandboxing: getEnvVar('ENABLE_SANDBOXING', true, parseBoolean)
};
const loggingConfig = {
    level: getEnvVar('LOG_LEVEL', 'info'),
    format: getEnvVar('LOG_FORMAT', 'text'),
    enableFileLogging: getEnvVar('ENABLE_FILE_LOGGING', false, parseBoolean)
};
const appConfig = {
    gitlab: gitlabConfig,
    claude: claudeConfig,
    workspace: workspaceConfig,
    security: securityConfig,
    logging: loggingConfig
};
function validateConfig() {
    const errors = [];
    // Validate GitLab configuration
    if (!gitlabConfig.token) {
        errors.push('GITLAB_TOKEN is required');
    }
    if (!gitlabConfig.url.startsWith('http')) {
        errors.push('GITLAB_URL must be a valid HTTP(S) URL');
    }
    // Validate Claude configuration
    if (!claudeConfig.apiKey) {
        errors.push('CLAUDE_API_KEY is required');
    }
    // Validate workspace limits
    if (workspaceConfig.maxSizeMB <= 0) {
        errors.push('MAX_WORKSPACE_SIZE_MB must be positive');
    }
    if (workspaceConfig.maxConcurrent <= 0) {
        errors.push('MAX_CONCURRENT_WORKSPACES must be positive');
    }
    // Validate logging level
    const validLogLevels = [
        'debug',
        'info',
        'warn',
        'error'
    ];
    if (!validLogLevels.includes(loggingConfig.level)) {
        errors.push('LOG_LEVEL must be one of: debug, info, warn, error');
    }
    if (errors.length > 0) {
        throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
    }
}
function getWorkspaceBaseDir() {
    const baseDir = getEnvVar('WORKSPACE_BASE_DIR', (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["resolve"])(process.cwd(), 'workspaces'));
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["resolve"])(baseDir);
}
function getCacheDir() {
    const cacheDir = getEnvVar('CACHE_DIR', (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["resolve"])(process.cwd(), '.cache'));
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["resolve"])(cacheDir);
}
function isDevelopment() {
    return getEnvVar('NODE_ENV', 'development') === 'development';
}
function isProduction() {
    return getEnvVar('NODE_ENV', 'development') === 'production';
}
function initializeConfig() {
    try {
        validateConfig();
        console.log('Configuration loaded successfully');
        if (isDevelopment()) {
            console.log('Running in development mode');
            console.log('Workspace base directory:', getWorkspaceBaseDir());
            console.log('Cache directory:', getCacheDir());
        }
    } catch (error) {
        console.error('Configuration initialization failed:', error);
        process.exit(1);
    }
}
// Auto-initialize on import in production
if (isProduction()) {
    initializeConfig();
}
}}),
"[project]/src/managers/RepositoryManager.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Repository Manager - Core repository operations and workspace management
 */ __turbopack_context__.s({
    "RepositoryManager": (()=>RepositoryManager)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/nanoid/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$gitOperations$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/gitOperations.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$settings$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/config/settings.ts [app-route] (ecmascript)");
;
;
;
;
;
class RepositoryManager {
    cacheManager;
    workspaceManager;
    workspaces;
    gitOps;
    constructor(cacheManager, workspaceManager// Will be injected from index.ts
    ){
        this.cacheManager = cacheManager;
        this.workspaceManager = workspaceManager;
        this.workspaces = new Map();
        this.gitOps = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$gitOperations$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GitOperations"]();
    }
    /**
   * Clone a repository to a new workspace
   */ async cloneRepository(repoUrl, options = {}) {
        try {
            // Check for existing workspace with same repo and branch
            const duplicateCheck = await this.checkForDuplicateWorkspace(repoUrl, options.branch);
            if (duplicateCheck.success && duplicateCheck.data) {
                return {
                    success: false,
                    error: new Error(`Workspace already exists for ${repoUrl} on branch ${duplicateCheck.data.branch} (ID: ${duplicateCheck.data.id}). Use existing workspace or clean it first.`)
                };
            }
            // Generate workspace ID
            const workspaceId = options.workspaceId || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])(10);
            // Create workspace directory
            const workspaceBaseDir = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$settings$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getWorkspaceBaseDir"])();
            const workspacePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(workspaceBaseDir, `workspace-${workspaceId}`);
            // Ensure base directory exists
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["mkdir"])(workspaceBaseDir, {
                recursive: true
            });
            // Validate Git URL
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$gitOperations$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GitOperations"].validateGitUrl(repoUrl)) {
                return {
                    success: false,
                    error: new Error(`Invalid Git URL: ${repoUrl}`)
                };
            }
            // Clone repository
            const cloneResult = await this.gitOps.cloneRepository(repoUrl, workspacePath, {
                ...options.branch && {
                    branch: options.branch
                },
                depth: options.depth || 1,
                singleBranch: options.singleBranch !== false
            });
            if (!cloneResult.success) {
                return cloneResult;
            }
            // Get actual current branch (in case Git auto-selected default branch)
            const currentBranchResult = await this.gitOps.getCurrentBranch(workspacePath);
            if (!currentBranchResult.success) {
                return {
                    success: false,
                    error: new Error(`Failed to get current branch: ${currentBranchResult.error.message}`)
                };
            }
            const actualBranch = currentBranchResult.data;
            // Get commit hash
            const commitResult = await this.gitOps.getCurrentCommitHash(workspacePath);
            if (!commitResult.success) {
                return {
                    success: false,
                    error: new Error(`Failed to get commit hash: ${commitResult.error.message}`)
                };
            }
            // Calculate workspace size
            const size = await this.calculateWorkspaceSize(workspacePath);
            // Create workspace object
            const workspace = {
                id: workspaceId,
                path: workspacePath,
                repoUrl,
                branch: actualBranch,
                createdAt: new Date(),
                lastAccessed: new Date(),
                metadata: {
                    size,
                    commitHash: commitResult.data,
                    isActive: true,
                    ...options.tags && {
                        tags: options.tags
                    }
                }
            };
            // Store workspace
            this.workspaces.set(workspaceId, workspace);
            // Perform initial directory analysis and cache it
            const analysisResult = await this.cacheManager.analyzeDirectory(workspacePath);
            if (analysisResult.success) {
                await this.cacheManager.setCache(workspacePath, analysisResult.data, commitResult.data);
            }
            return {
                success: true,
                data: workspace
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to clone repository: ${error}`)
            };
        }
    }
    /**
   * Get workspace by ID
   */ getWorkspace(workspaceId) {
        const workspace = this.workspaces.get(workspaceId);
        if (workspace) {
            // Update last accessed time
            workspace.lastAccessed = new Date();
            this.workspaces.set(workspaceId, workspace);
        }
        return workspace || null;
    }
    /**
   * List all workspaces
   */ listWorkspaces() {
        return Array.from(this.workspaces.values()).sort((a, b)=>b.lastAccessed.getTime() - a.lastAccessed.getTime());
    }
    /**
   * Load all workspaces from persistent storage into memory
   */ async loadAllWorkspacesFromStorage() {
        try {
            if (!this.workspaceManager) {
                return {
                    success: true,
                    data: undefined
                };
            }
            const allWorkspacesResult = await this.workspaceManager.getAllWorkspaces();
            if (!allWorkspacesResult.success) {
                return allWorkspacesResult;
            }
            // Load all workspaces into memory
            for (const workspace of allWorkspacesResult.data){
                this.workspaces.set(workspace.id, workspace);
            }
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to load workspaces from storage: ${error}`)
            };
        }
    }
    /**
   * Get active workspaces only
   */ getActiveWorkspaces() {
        return this.listWorkspaces().filter((ws)=>ws.metadata?.isActive);
    }
    /**
   * Update workspace metadata
   */ async updateWorkspace(workspaceId, updates) {
        try {
            const workspace = this.workspaces.get(workspaceId);
            if (!workspace) {
                return {
                    success: false,
                    error: new Error(`Workspace ${workspaceId} not found`)
                };
            }
            // Update workspace
            const updatedWorkspace = {
                ...workspace,
                ...updates,
                lastAccessed: new Date(),
                metadata: {
                    ...workspace.metadata,
                    ...updates.metadata
                }
            };
            this.workspaces.set(workspaceId, updatedWorkspace);
            return {
                success: true,
                data: updatedWorkspace
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to update workspace: ${error}`)
            };
        }
    }
    /**
   * Switch to a different branch
   */ async switchBranch(workspaceId, branchName) {
        try {
            const workspace = this.getWorkspace(workspaceId);
            if (!workspace) {
                return {
                    success: false,
                    error: new Error(`Workspace ${workspaceId} not found`)
                };
            }
            // Switch branch using git operations
            const switchResult = await this.gitOps.switchBranch(workspace.path, branchName);
            if (!switchResult.success) {
                return switchResult;
            }
            // Update workspace branch
            await this.updateWorkspace(workspaceId, {
                branch: branchName
            });
            // Invalidate cache since branch changed
            await this.cacheManager.invalidateCache(workspace.path);
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to switch branch: ${error}`)
            };
        }
    }
    /**
   * Pull latest changes
   */ async pullChanges(workspaceId) {
        try {
            const workspace = this.getWorkspace(workspaceId);
            if (!workspace) {
                return {
                    success: false,
                    error: new Error(`Workspace ${workspaceId} not found`)
                };
            }
            // Pull changes
            const pullResult = await this.gitOps.pullChanges(workspace.path);
            if (!pullResult.success) {
                return pullResult;
            }
            // Update commit hash
            const commitResult = await this.gitOps.getCurrentCommitHash(workspace.path);
            if (commitResult.success) {
                await this.updateWorkspace(workspaceId, {
                    metadata: {
                        commitHash: commitResult.data
                    }
                });
                // Invalidate cache since content changed
                await this.cacheManager.invalidateCache(workspace.path);
            }
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to pull changes: ${error}`)
            };
        }
    }
    /**
   * Clean up workspace
   */ async cleanupWorkspace(workspaceId) {
        try {
            let workspace = this.workspaces.get(workspaceId);
            // If not in memory, try to load from WorkspaceManager
            if (!workspace && this.workspaceManager) {
                const loadResult = await this.workspaceManager.loadWorkspace(workspaceId);
                if (loadResult.success) {
                    workspace = loadResult.data;
                }
            }
            // If still not found, try to construct path based on workspace ID
            if (!workspace) {
                const workspaceBaseDir = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$settings$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getWorkspaceBaseDir"])();
                const workspacePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(workspaceBaseDir, `workspace-${workspaceId}`);
                // Check if directory exists
                try {
                    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["access"])(workspacePath);
                    // Directory exists, create a minimal workspace object for cleanup
                    workspace = {
                        id: workspaceId,
                        path: workspacePath,
                        repoUrl: 'unknown',
                        branch: 'unknown',
                        createdAt: new Date(),
                        lastAccessed: new Date()
                    };
                } catch  {
                    return {
                        success: false,
                        error: new Error(`Workspace ${workspaceId} not found in memory, persistent storage, or file system`)
                    };
                }
            }
            // Remove workspace directory
            try {
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["access"])(workspace.path);
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["rm"])(workspace.path, {
                    recursive: true,
                    force: true
                });
            } catch (error) {
                // Log warning but don't fail - directory might already be gone
                console.warn(`Warning: Could not remove directory ${workspace.path}:`, error);
            }
            // Remove from memory if it was there
            this.workspaces.delete(workspaceId);
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to cleanup workspace: ${error}`)
            };
        }
    }
    /**
   * Clean up all inactive workspaces
   */ async cleanupInactiveWorkspaces() {
        try {
            let cleanedCount = 0;
            // Get workspaces from WorkspaceManager if available, otherwise use in-memory
            let workspaces = [];
            if (this.workspaceManager) {
                const allWorkspacesResult = await this.workspaceManager.getAllWorkspaces();
                if (allWorkspacesResult.success) {
                    workspaces = allWorkspacesResult.data.filter((ws)=>!ws.metadata?.isActive);
                } else {
                    workspaces = this.listWorkspaces().filter((ws)=>!ws.metadata?.isActive);
                }
            } else {
                workspaces = this.listWorkspaces().filter((ws)=>!ws.metadata?.isActive);
            }
            for (const workspace of workspaces){
                const result = await this.cleanupWorkspace(workspace.id);
                if (result.success) {
                    cleanedCount++;
                }
            }
            return {
                success: true,
                data: cleanedCount
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to cleanup inactive workspaces: ${error}`)
            };
        }
    }
    /**
   * Get Git operations instance for a workspace
   */ getGitOperations(workspacePath) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$gitOperations$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GitOperations"](workspacePath);
    }
    /**
   * Calculate total size of workspace directory
   */ async calculateWorkspaceSize(directoryPath) {
        try {
            const analysisResult = await this.cacheManager.analyzeDirectory(directoryPath);
            if (analysisResult.success) {
                // Estimate size based on file count (rough approximation)
                return analysisResult.data.fileCount * 1024; // 1KB average per file
            }
            return 0;
        } catch  {
            return 0;
        }
    }
    /**
   * Check for existing workspace with same repository and branch
   */ async checkForDuplicateWorkspace(repoUrl, targetBranch) {
        try {
            // Skip duplicate check if no WorkspaceManager is available
            if (!this.workspaceManager) {
                return {
                    success: true,
                    data: null
                };
            }
            const existingWorkspacesResult = await this.workspaceManager.getAllWorkspaces();
            if (!existingWorkspacesResult.success) {
                return existingWorkspacesResult;
            }
            const existingWorkspaces = existingWorkspacesResult.data;
            // Find duplicate workspace
            for (const workspace of existingWorkspaces){
                // Check if same repository URL
                if (workspace.repoUrl === repoUrl) {
                    // If no target branch specified, check if we can get the default branch
                    if (!targetBranch) {
                        continue;
                    }
                    // Check if same branch
                    if (workspace.branch === targetBranch) {
                        // Additional check: see if it's the same commit (to avoid duplicate work)
                        try {
                            const currentCommitResult = await this.gitOps.getCurrentCommitHash(workspace.path);
                            if (currentCommitResult.success && workspace.metadata?.commitHash === currentCommitResult.data) {
                                return {
                                    success: true,
                                    data: workspace
                                };
                            }
                        } catch  {
                            // If we can't check commit (e.g., directory doesn't exist), still consider it a duplicate
                            return {
                                success: true,
                                data: workspace
                            };
                        }
                    }
                }
            }
            return {
                success: true,
                data: null
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to check for duplicate workspace: ${error}`)
            };
        }
    }
    /**
   * Get workspace statistics
   */ getWorkspaceStats() {
        const all = this.listWorkspaces();
        const active = all.filter((ws)=>ws.metadata?.isActive);
        const totalSize = all.reduce((sum, ws)=>sum + (ws.metadata?.size || 0), 0);
        return {
            total: all.length,
            active: active.length,
            inactive: all.length - active.length,
            totalSize
        };
    }
}
}}),
"[project]/src/managers/WorkspaceManager.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Workspace Manager - Persistent workspace management
 */ __turbopack_context__.s({
    "WorkspaceManager": (()=>WorkspaceManager)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$settings$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/config/settings.ts [app-route] (ecmascript)");
;
;
;
class WorkspaceManager {
    workspaceIndexPath;
    workspaceIndex;
    constructor(){
        const workspaceBaseDir = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$settings$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getWorkspaceBaseDir"])();
        this.workspaceIndexPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(workspaceBaseDir, '.workspace-index.json');
        this.workspaceIndex = {
            workspaces: {},
            lastUpdated: new Date().toISOString(),
            version: '1.0.0'
        };
    }
    /**
   * Initialize workspace manager (load existing workspaces)
   */ async initialize() {
        try {
            await this.loadWorkspaceIndex();
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to initialize workspace manager: ${error}`)
            };
        }
    }
    /**
   * Save workspace to persistent storage
   */ async saveWorkspace(workspace) {
        try {
            this.workspaceIndex.workspaces[workspace.id] = workspace;
            this.workspaceIndex.lastUpdated = new Date().toISOString();
            await this.saveWorkspaceIndex();
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to save workspace: ${error}`)
            };
        }
    }
    /**
   * Load workspace from persistent storage
   */ async loadWorkspace(workspaceId) {
        try {
            await this.loadWorkspaceIndex();
            const workspace = this.workspaceIndex.workspaces[workspaceId];
            if (!workspace) {
                return {
                    success: false,
                    error: new Error(`Workspace ${workspaceId} not found`)
                };
            }
            // Update last accessed time
            workspace.lastAccessed = new Date();
            await this.saveWorkspace(workspace);
            return {
                success: true,
                data: workspace
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to load workspace: ${error}`)
            };
        }
    }
    /**
   * Get all workspaces from persistent storage
   */ async getAllWorkspaces() {
        try {
            await this.loadWorkspaceIndex();
            const workspaces = Object.values(this.workspaceIndex.workspaces).sort((a, b)=>new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime());
            return {
                success: true,
                data: workspaces
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get all workspaces: ${error}`)
            };
        }
    }
    /**
   * Delete workspace from persistent storage
   */ async deleteWorkspace(workspaceId) {
        try {
            delete this.workspaceIndex.workspaces[workspaceId];
            this.workspaceIndex.lastUpdated = new Date().toISOString();
            await this.saveWorkspaceIndex();
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to delete workspace: ${error}`)
            };
        }
    }
    /**
   * Update workspace in persistent storage
   */ async updateWorkspace(workspace) {
        try {
            if (!this.workspaceIndex.workspaces[workspace.id]) {
                return {
                    success: false,
                    error: new Error(`Workspace ${workspace.id} not found`)
                };
            }
            return await this.saveWorkspace(workspace);
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to update workspace: ${error}`)
            };
        }
    }
    /**
   * Check if workspace exists in storage
   */ async workspaceExists(workspaceId) {
        try {
            await this.loadWorkspaceIndex();
            return workspaceId in this.workspaceIndex.workspaces;
        } catch  {
            return false;
        }
    }
    /**
   * Get workspace statistics
   */ async getWorkspaceStats() {
        try {
            const result = await this.getAllWorkspaces();
            if (!result.success) {
                return result;
            }
            const workspaces = result.data;
            const active = workspaces.filter((ws)=>ws.metadata?.isActive);
            const totalSize = workspaces.reduce((sum, ws)=>sum + (ws.metadata?.size || 0), 0);
            const accessTimes = workspaces.map((ws)=>new Date(ws.lastAccessed));
            const oldestAccess = accessTimes.length > 0 ? new Date(Math.min(...accessTimes.map((d)=>d.getTime()))) : null;
            const newestAccess = accessTimes.length > 0 ? new Date(Math.max(...accessTimes.map((d)=>d.getTime()))) : null;
            return {
                success: true,
                data: {
                    total: workspaces.length,
                    active: active.length,
                    inactive: workspaces.length - active.length,
                    totalSize,
                    oldestAccess,
                    newestAccess
                }
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to get workspace stats: ${error}`)
            };
        }
    }
    /**
   * Cleanup old workspaces (mark as inactive or delete)
   */ async cleanupOldWorkspaces(maxAgeHours = 24 * 7) {
        try {
            const result = await this.getAllWorkspaces();
            if (!result.success) {
                return result;
            }
            const cutoffTime = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000);
            let cleanedCount = 0;
            for (const workspace of result.data){
                if (new Date(workspace.lastAccessed) < cutoffTime && workspace.metadata?.isActive) {
                    workspace.metadata.isActive = false;
                    await this.saveWorkspace(workspace);
                    cleanedCount++;
                }
            }
            return {
                success: true,
                data: cleanedCount
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to cleanup old workspaces: ${error}`)
            };
        }
    }
    /**
   * Load workspace index from disk
   */ async loadWorkspaceIndex() {
        try {
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["stat"])(this.workspaceIndexPath);
            const content = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["readFile"])(this.workspaceIndexPath, 'utf-8');
            this.workspaceIndex = JSON.parse(content);
            // Convert date strings back to Date objects
            Object.values(this.workspaceIndex.workspaces).forEach((workspace)=>{
                workspace.createdAt = new Date(workspace.createdAt);
                workspace.lastAccessed = new Date(workspace.lastAccessed);
            });
        } catch  {
            // File doesn't exist or is corrupted, start with empty index
            this.workspaceIndex = {
                workspaces: {},
                lastUpdated: new Date().toISOString(),
                version: '1.0.0'
            };
        }
    }
    /**
   * Save workspace index to disk
   */ async saveWorkspaceIndex() {
        const content = JSON.stringify(this.workspaceIndex, null, 2);
        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["writeFile"])(this.workspaceIndexPath, content, 'utf-8');
    }
    /**
   * Get workspace index file path
   */ getIndexPath() {
        return this.workspaceIndexPath;
    }
}
}}),
"[externals]/node:crypto [external] (node:crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}}),
"[externals]/node:url [external] (node:url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}}),
"[externals]/node:fs [external] (node:fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}}),
"[externals]/node:stream [external] (node:stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}}),
"[externals]/node:string_decoder [external] (node:string_decoder, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:string_decoder", () => require("node:string_decoder"));

module.exports = mod;
}}),
"[project]/src/managers/CacheManager.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Cache Manager for directory analysis and AI cache files
 */ __turbopack_context__.s({
    "CacheManager": (()=>CacheManager)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$glob$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/glob/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$glob$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/glob/dist/esm/index.js [app-route] (ecmascript) <locals>");
;
;
;
;
class CacheManager {
    options;
    cacheFileName;
    cacheVersion;
    constructor(options){
        this.options = options;
        this.cacheFileName = '.ai-cache';
        this.cacheVersion = '1.0.0';
    }
    /**
   * Get cache data for a directory
   */ async getCache(directoryPath) {
        try {
            const cacheFilePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(directoryPath, this.cacheFileName);
            // Check if cache file exists
            try {
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["access"])(cacheFilePath);
            } catch  {
                return {
                    success: true,
                    data: null
                };
            }
            const cacheContent = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["readFile"])(cacheFilePath, 'utf-8');
            const cacheData = JSON.parse(cacheContent);
            // Validate cache version
            if (cacheData.version !== this.cacheVersion) {
                return {
                    success: true,
                    data: null
                };
            }
            // Check if cache is expired
            const isExpired = this.isCacheExpired(cacheData.lastUpdated);
            if (isExpired) {
                return {
                    success: true,
                    data: null
                };
            }
            // Verify directory hasn't changed
            const currentHash = await this.calculateDirectoryHash(directoryPath);
            if (currentHash.success && currentHash.data !== cacheData.directoryHash) {
                return {
                    success: true,
                    data: null
                };
            }
            return {
                success: true,
                data: cacheData
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to read cache: ${error}`)
            };
        }
    }
    /**
   * Save cache data for a directory
   */ async setCache(directoryPath, analysis, commitHash) {
        try {
            const directoryHashResult = await this.calculateDirectoryHash(directoryPath);
            if (!directoryHashResult.success) {
                return directoryHashResult;
            }
            const cacheData = {
                lastCommitHash: commitHash,
                directoryHash: directoryHashResult.data,
                lastUpdated: new Date(),
                analysis,
                version: this.cacheVersion
            };
            const cacheFilePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(directoryPath, this.cacheFileName);
            const cacheContent = JSON.stringify(cacheData, null, 2);
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["writeFile"])(cacheFilePath, cacheContent, 'utf-8');
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to save cache: ${error}`)
            };
        }
    }
    /**
   * Invalidate cache for a directory
   */ async invalidateCache(directoryPath) {
        try {
            const cacheFilePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(directoryPath, this.cacheFileName);
            try {
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["access"])(cacheFilePath);
                // If file exists, delete it by writing empty content
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["writeFile"])(cacheFilePath, '', 'utf-8');
            } catch  {
            // File doesn't exist, nothing to do
            }
            return {
                success: true,
                data: undefined
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to invalidate cache: ${error}`)
            };
        }
    }
    /**
   * Analyze directory structure and create file tree
   */ async analyzeDirectory(directoryPath) {
        try {
            const files = await this.getDirectoryFiles(directoryPath);
            const structure = await this.buildFileTree(directoryPath, files);
            const languages = this.detectLanguages(files);
            const analysis = {
                fileCount: files.length,
                languages,
                structure
            };
            return {
                success: true,
                data: analysis
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to analyze directory: ${error}`)
            };
        }
    }
    /**
   * Get all files in directory matching patterns
   */ async getDirectoryFiles(directoryPath) {
        const includePatterns = this.options.includePatterns.length > 0 ? this.options.includePatterns : [
            '**/*'
        ];
        const allFiles = [];
        for (const pattern of includePatterns){
            const files = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$glob$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["glob"])(pattern, {
                cwd: directoryPath,
                ignore: this.options.excludePatterns,
                nodir: true,
                dot: false
            });
            allFiles.push(...files);
        }
        // Remove duplicates and sort
        return [
            ...new Set(allFiles)
        ].sort();
    }
    /**
   * Build file tree structure
   */ async buildFileTree(basePath, files) {
        const tree = new Map();
        const rootNodes = [];
        for (const file of files){
            const parts = file.split('/');
            let currentPath = '';
            let currentLevel = rootNodes;
            let parentMap = tree;
            for(let i = 0; i < parts.length; i++){
                const part = parts[i];
                const isFile = i === parts.length - 1;
                currentPath = currentPath ? `${currentPath}/${part}` : part;
                const fullPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(basePath, currentPath);
                if (!parentMap.has(currentPath)) {
                    const node = {
                        name: part,
                        path: fullPath,
                        type: isFile ? 'file' : 'directory',
                        ...isFile ? {} : {
                            children: []
                        }
                    };
                    // Add file metadata for files
                    if (isFile) {
                        try {
                            const stats = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["stat"])(fullPath);
                            node.size = stats.size;
                            node.lastModified = stats.mtime;
                            node.mimeType = this.getMimeType(part);
                        } catch  {
                        // Ignore stat errors
                        }
                    }
                    parentMap.set(currentPath, node);
                    currentLevel.push(node);
                }
                const currentNode = parentMap.get(currentPath);
                if (!isFile && currentNode.children) {
                    currentLevel = currentNode.children;
                }
            }
        }
        return rootNodes;
    }
    /**
   * Detect programming languages from file extensions
   */ detectLanguages(files) {
        const extensionMap = {
            '.js': 'JavaScript',
            '.ts': 'TypeScript',
            '.jsx': 'React',
            '.tsx': 'React TypeScript',
            '.py': 'Python',
            '.java': 'Java',
            '.cpp': 'C++',
            '.c': 'C',
            '.cs': 'C#',
            '.go': 'Go',
            '.rs': 'Rust',
            '.php': 'PHP',
            '.rb': 'Ruby',
            '.swift': 'Swift',
            '.kt': 'Kotlin',
            '.scala': 'Scala',
            '.sh': 'Shell',
            '.yml': 'YAML',
            '.yaml': 'YAML',
            '.json': 'JSON',
            '.xml': 'XML',
            '.html': 'HTML',
            '.css': 'CSS',
            '.scss': 'SCSS',
            '.sass': 'Sass',
            '.md': 'Markdown',
            '.sql': 'SQL'
        };
        const languages = new Set();
        for (const file of files){
            const ext = file.substring(file.lastIndexOf('.'));
            const language = extensionMap[ext.toLowerCase()];
            if (language) {
                languages.add(language);
            }
        }
        return Array.from(languages).sort();
    }
    /**
   * Get MIME type for file extension
   */ getMimeType(filename) {
        const ext = filename.substring(filename.lastIndexOf('.'));
        const mimeMap = {
            '.js': 'application/javascript',
            '.ts': 'application/typescript',
            '.json': 'application/json',
            '.html': 'text/html',
            '.css': 'text/css',
            '.md': 'text/markdown',
            '.txt': 'text/plain',
            '.py': 'text/x-python',
            '.java': 'text/x-java-source',
            '.cpp': 'text/x-c++src',
            '.c': 'text/x-csrc'
        };
        return mimeMap[ext.toLowerCase()] || 'application/octet-stream';
    }
    /**
   * Calculate hash of directory contents
   */ async calculateDirectoryHash(directoryPath) {
        try {
            const files = await this.getDirectoryFiles(directoryPath);
            const hash = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHash"])('sha256');
            // Sort files for consistent hashing
            files.sort();
            for (const file of files){
                const filePath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["join"])(directoryPath, file);
                try {
                    const stats = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["stat"])(filePath);
                    // Include file path, size, and modification time in hash
                    hash.update(`${file}:${stats.size}:${stats.mtime.getTime()}`);
                } catch  {
                    continue;
                }
            }
            return {
                success: true,
                data: hash.digest('hex')
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to calculate directory hash: ${error}`)
            };
        }
    }
    /**
   * Check if cache is expired
   */ isCacheExpired(lastUpdated) {
        const expiryTime = this.options.expiryDays * 24 * 60 * 60 * 1000; // Convert days to milliseconds
        const now = new Date().getTime();
        const cacheTime = lastUpdated.getTime();
        return now - cacheTime > expiryTime;
    }
    /**
   * Clean up expired cache files in workspace
   */ async cleanupExpiredCache(workspaceId, workspacePath) {
        try {
            let cleanedCount = 0;
            const cacheFiles = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$glob$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["glob"])(`**/${this.cacheFileName}`, {
                cwd: workspacePath,
                absolute: true
            });
            for (const cacheFile of cacheFiles){
                try {
                    const content = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["readFile"])(cacheFile, 'utf-8');
                    const cacheData = JSON.parse(content);
                    if (this.isCacheExpired(cacheData.lastUpdated)) {
                        await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["writeFile"])(cacheFile, '', 'utf-8'); // Clear the file
                        cleanedCount++;
                    }
                } catch  {
                    continue;
                }
            }
            return {
                success: true,
                data: cleanedCount
            };
        } catch (error) {
            return {
                success: false,
                error: new Error(`Failed to cleanup expired cache: ${error}`)
            };
        }
    }
}
}}),
"[project]/src/app/api/cleanup/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$managers$2f$RepositoryManager$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/managers/RepositoryManager.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$managers$2f$WorkspaceManager$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/managers/WorkspaceManager.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$managers$2f$CacheManager$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/managers/CacheManager.ts [app-route] (ecmascript)");
;
;
;
;
const cacheManager = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$managers$2f$CacheManager$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CacheManager"]({
    expiryDays: 7,
    maxCacheSize: 100 * 1024 * 1024,
    includePatterns: [
        '**/*.ts',
        '**/*.js',
        '**/*.json',
        '**/*.md',
        '**/*.yml',
        '**/*.yaml'
    ],
    excludePatterns: [
        'node_modules/**',
        'dist/**',
        '.git/**',
        '**/.DS_Store'
    ]
});
const workspaceManager = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$managers$2f$WorkspaceManager$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WorkspaceManager"]();
const repositoryManager = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$managers$2f$RepositoryManager$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RepositoryManager"](cacheManager, workspaceManager);
async function POST(request) {
    try {
        const { workspaceId, all = false, force = false } = await request.json();
        // Initialize workspace manager
        const initResult = await workspaceManager.initialize();
        if (!initResult.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to initialize workspace manager',
                details: initResult.error?.message
            }, {
                status: 500
            });
        }
        if (workspaceId) {
            // Clean specific workspace
            const cleanResult = await repositoryManager.cleanupWorkspace(workspaceId);
            if (!cleanResult.success) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Failed to clean workspace',
                    details: cleanResult.error?.message
                }, {
                    status: 500
                });
            }
            // Remove from persistent storage
            const deleteResult = await workspaceManager.deleteWorkspace(workspaceId);
            if (!deleteResult.success) {
                console.warn('Warning: Failed to remove workspace from persistent storage');
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: true,
                message: `Workspace ${workspaceId} cleaned successfully`,
                cleanedWorkspaces: 1
            });
        } else if (all) {
            if (!force) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Force flag is required for bulk cleanup operations'
                }, {
                    status: 400
                });
            }
            // Get all workspaces
            const workspacesResult = await workspaceManager.getAllWorkspaces();
            if (!workspacesResult.success) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Failed to get workspaces',
                    details: workspacesResult.error?.message
                }, {
                    status: 500
                });
            }
            const allWorkspaces = workspacesResult.data;
            let cleanedCount = 0;
            const errors = [];
            // Clean each workspace
            for (const workspace of allWorkspaces){
                try {
                    const cleanResult = await repositoryManager.cleanupWorkspace(workspace.id);
                    if (cleanResult.success) {
                        await workspaceManager.deleteWorkspace(workspace.id);
                        cleanedCount++;
                    } else {
                        errors.push(`Failed to clean ${workspace.id}: ${cleanResult.error?.message}`);
                    }
                } catch (error) {
                    errors.push(`Error cleaning ${workspace.id}: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: true,
                message: `Cleaned ${cleanedCount}/${allWorkspaces.length} workspaces`,
                cleanedWorkspaces: cleanedCount,
                totalWorkspaces: allWorkspaces.length,
                errors: errors.length > 0 ? errors : undefined
            });
        } else {
            // Get workspace stats for information
            const statsResult = await workspaceManager.getWorkspaceStats();
            if (!statsResult.success) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Failed to get workspace stats',
                    details: statsResult.error?.message
                }, {
                    status: 500
                });
            }
            const stats = statsResult.data;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: true,
                message: 'Specify workspaceId for single cleanup or use all=true for bulk cleanup',
                stats: {
                    total: stats.total,
                    active: stats.active,
                    inactive: stats.inactive,
                    totalSizeMB: Math.round(stats.totalSize / 1024 / 1024)
                }
            });
        }
    } catch (error) {
        console.error('Error in cleanup API:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Internal server error',
            details: error instanceof Error ? error.message : String(error)
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__8023f65e._.js.map